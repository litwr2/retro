<HTML>

<HEAD>
  <META NAME="keywords" lang="en" 
      CONTENT="Lidovski, Commodore, +4, plus/4, Emulator, DOS, Forever?">
  <META NAME="author" CONTENT="Vladimir Lidovski">
  <META NAME="copyright" CONTENT="&copy; 2007 V Lidovski">
  <TITLE>Commodore +4 Emulator Forever?</TITLE>
</HEAD>

<body background=../cbm2.gif style=background-attachment:fixed>

<div align=center>

<h1>Commodore Plus/4 Emulator `Forever?' documentation</h1>

<h2>CONTENTS</h2>

<p><a href=#0>Preview</a>
<p><a href=#1>OS</a>
<p><a href=#DOS>Why Assembler &amp; DOS?!</a>
<p><a href=#2>Used IBM PC hardware resources</a>
<p><a href=#3>Keyboard</a>
<p><a href=#4>Joysticks</a>
<p><a href=#DD>Disk Drives</a>
<p><a href=#SND>Sound</a>
<p><a href=#VSS>Video subsystem</a>
<p><a href=#5>Mouse</a>
<p><a href=#6>ROMs</a>
<p><a href=#7>Main Features Of The Emulator</a>
<p><a href=#8>CPU JAM instructions</a>
<p><a href=#9>I/O Ports Emulation</a>
<p><a href=#10>TED Emulation</a>
<p><a href=#11>Commodore +4 main specifications</a>
<p><a href=#12>C+4 vs C64</a>
<p><a href=#13>Debugger</a>
<p><a href=#14>CPU and TED Timing</a>
<p><a href=#15>Datasette Emulation</a>
<p><a href=#16>Menus</a>
<p><a href=#17>CTF Format</a>
<p><a href=#18>C2F Format</a>
<p><a href=#CFG>CFG Format</a>
<p><a href=#CLP>Command Line Parameters</a>
<p><a href=#19>Compilation</a>
<p><a href=#20>(C) Copyright</a>
<p><a href=#BUG>Bugs reports</a>
<p><a href=#21>History and the last updates</a>
</div>


<a name=0></a><h2 align=center>Preview</h2>

<p>I think I've created a unique emulator because I haven't come across any Commodore Plus/4 (16 or 116) since March 1991. I've also never owned a Commodore disk drive. This version of the emulator has been created solely from some old documentation I had and some that I found on the Internet (e.g., `c64doc' by John West and Marko Makela, `Extra Instructions Of The 65XX Series CPU' by Adam Vardy) and some advice
from Attila Grosz.  It's written only in 100% 80486 assembler (16-bit mode).



<a name=1></a><h2 align=center>OS</h2>

<p>Reprogramming the timer hardware has made it impossible to run the emulator from the Microsoft Windows GUI environment. Users are advised to utilize DOS or Windows 95/98/Me DOS mode. For those on NT/2000/XP, Linux, or FreeBSD, creating a DOS boot disk (or CD-ROM) is a viable option to run this program.  Another option is to use a virtual machine to boot DOS. DOSBOX is the best choice as it properly emulates the Sound Blaster, but it can be quite slow. I have found that other virtual machines such as VirtualBox and Qemu+KVM are much faster.


<a name=DOS></a><h2 align=center>Why Assembler &amp; DOS?!</h2>

<p>Why this old nearly completely forgotten OS is used as base for 2007
software? There are several reasons.

<ol>
<li>The skeleton of the emulator was created in 1996/97
in the existing DOS atmosphere, work was stopped at the beginning of 1998 and
resumed only at the end of 2002. So the emulator skeleton contains the spirit
of other years.

<li>Author had found that translation
to other OS and from assembler to higher level programming language is
too difficult now. He has a choice. He can either continue to develop the
emulator or begin big work to transfer its code to other systems.

<li>The better emulators are only available for Open Unix-like OS and Microsoft 
Windows (Plus4emu, Yape). Presented emulator is the best for DOS forever!

<li>Author's computer of the middle of 1990s was 486DX-120 and Assembler was
the only choice in attempt to reach 100% performance with it.

<li>The programming in Assembler under DOS without a debugger is very difficult
and time consumptive &mdash; this makes the pleasure of the emulator creation
longer.
</ol>



<a name=2></a><h2 align=center>Used IBM hardware resources</h2>

<p>The emulator completely takes over interrupt 9 (keyboard) and intercepts
interrupt 8. The emulator uses only base DOS memory. The screen size is
selectable. It has direct access to the following ports: 20-21 (programmable
interrupt controller); 40, 43 (timer hardware &mdash; to set IRQ0 frequency to
37288Hz); 60, 64 (keyboard); 61 (speaker); 201 (joysticks); 388, 389 (Ad
Lib); 3C0, 3C1, 3C2, 3C4, 3C5, 3CE, 3CF (VGA); 3D4, 3D5, 3DA (color VGA);
3B4, 3B5, 3BA (mono VGA); 2x6, 2xA, 2xC, 2xE (Sound Blaster, x may be 2,4,6,
or 8). Several more VGA registers are used only for some video modes.


<a name=3></a><h2 align=center>Keyboard</h2>

<p>Some keys description:

<table align=center>
<tr><td>Alt<td>-<td>Commodore key
<tr><td>Tab<td>-<td>Run/Stop
<tr><td>F5<td>-<td>Change sound hardware (beeper, adlib, sb16, none)
<tr><td>F9<td>-<td>Debugger
<tr><td>F10<td>-<td>Exit to DOS (power off button)
<tr><td>F11<td>-<td>Reset button
<tr><td>Shift-F11<td>-<td>"Hardware" Reset button
<tr><td>F12<td>-<td>Emulator's file system &amp; options
<tr><td>Scroll Lock<td>-<td>Button Play on the datasette
<tr><td>Num Lock<td>-<td>Button Record on the datasette (press only it when 
message "PRESS PLAY & RECORD ON TAPE" appeared)
<tr><td>SysRq (Alt+PrintScreen)<td>-<td>Immediate exit to DOS (Warning! It can 
interrupt any operation, e.g. with a file)
</table>



<a name=4></a><h2 align=center>Joysticks</h2>

<p>You can use any combination of real analog joysticks and keyboard keys
for the joystick emulation. There are two keys sets for the emulation:

<ul>
<li>KEYS1 - Word Star like - SEDX/;
<li>KEYS2 - cursors and right shift keys.
</ul>



<a name=DD></a><h2 align=center>Disk Drives</h2>

<p>You can use units 8 and 9. There are two kinds of emulation of Commodore
DOS:

<ol>
<li>for D64-images;
<li>for IBM PC directory (FAT or CD-ROM).
</ol>

<p>The both emulations allow us to use the next BASIC DOS commands and
variables: DIRECTORY, DLOAD, LOAD, DSAVE, SAVE, VERIFY, INPUT#, GET#, PRINT#,
OPEN, CLOSE, SCRATCH, RENAME, HEADER, COLLECT, DS, DS$, ST, CMD, COPY. The
DOS commands U9/UI and U:/UJ are partially supported &mdash; they return the DOS
version in the DS$ and finish all i/o operations. The DOS command I
(INITIALIZE) finishes all i/o operations. The DOS command M-R (MEMORY READ)
may be used to read C1551 ROM and 5 256 bytes data buffers at addresses from
$300 to $7ff. The DOS command P (POSITION) is fully supported.

<p>So you can load/save programs, read/write/copy/rename/delete/... the PRG,
SEQ, USR, DEL files, get drive status and see directory in the any kind of
the emulation.

<p>The emulation on the D64 images supports direct access U1/UA, U2/UB, B-A,
B-F, # and B-P DOS commands that allows to use such programs as
<em>Zork</em>, <em>Hitchhiker's Guide</em>, <em>Blazin Forth</em>, etc.
The U1/UA can use the sectors map from D64 images, which provide it, that allows
to use the programs (e.g. <em>Typing Professor</em>) from copy-protected disk.
The COPY command is not supported for relative files only. A read-only
D64-image is considered as a write-protected disk by the emulator.

<p>The emulation on the IBM PC filesystems provides support for all types of
standard files and some DOS commands (C, R, S, P, N, V). It doesn't support
direct access commands like U1, B-A, M-W, etc. The relative files and COPY
command are fully supported. The HEADER command simply clears the current
directory from all not locked (not read-only) PRG and X00 files. The COLLECT
command doesn't produce any effect. The read-only files are considered as
locked by the emulator.

<p>You can use a pattern (like A??B*=P) in any command that allows it
(SCRATCH, DIRECTORY, ...). The SAVE/OPEN command supports usage of the @
replacement prefix.

<p>The both units are assigned to the current PC directory at the start of
the emulator. Use F7 in the menus for reassignments of the units.

<p>Usage of the IBM PC filesystems emulation gives more space and flexibility
especially for such programs like <em>Austrospeed Basic Compiler</em> or 
<em>SVS B.A.L. System</em>. So extract files from D64 and get some benefit!

<p>The following table shows all features of the DOS commands emulation.

<table align=center border=1>
<tr><td>DOS <td>BASIC<td>D64 <td>PC directory
<tr><td>N <td>HEADER <td>+ <td>%[1]
<tr><td>C <td>COPY <td>%[3] <td>%[4]
<tr><td>S <td>SCRATCH <td>+ <td>+
<tr><td>R <td>RENAME <td>+ <td>+
<tr><td>V <td>COLLECT <td>+ <td>+[2]
<tr><td>I <td> <td>+ <td>+
<tr><td>P <td>(RECORD) <td>+ <td>+
<tr><td>U1, UA <td> <td>+ <td>-
<tr><td>U2, UB <td> <td>+ <td>-
<tr><td>B-R <td> <td>- <td>-
<tr><td>B-W <td> <td>- <td>-
<tr><td>B-P <td> <td>+ <td>-
<tr><td>B-A <td> <td>+ <td>-
<tr><td>B-F <td> <td>+ <td>-
<tr><td>B-E <td> <td>- <td>-
<tr><td>M-R <td> <td>+[5] <td>+[5]
<tr><td>M-W <td> <td>- <td>-
<tr><td>M-E <td> <td>- <td>-
<tr><td>U3..U8, UC..UH <td> <td>- <td>-
<tr><td>U9, UI <td> <td>+ <td>+
<tr><td>U:, UJ <td> <td>+ <td>+
<tr><td>%R <td> <td>+[7] <td>+[7]
<tr><td>%S <td> <td>-[6] <td>+[7]
<tr><td>%number <td> <td>- <td>-
<tr><td>& <td> <td>- <td>-
</table>

<p>[1] - doesn't remove r/o files<br>
[2] - the splat files are impossible for DOS on the PC filesystem<br>
[3] - it can't copy relative files<br>
[4] - it can't correctly combine relative files with different record size<br>
[5] - it can be used to access to memory ranges at $300-$7ff (RAM) and
$c000-$ffff (ROM). The IEC emulations algorithms is not the exact copy of
C1551 subroutines &mdash; so the automatic distribution of the 256 bytes
buffers for i/o operations may differ from C1551<br>
[6] - the sector interleave is always (except directory) set to 1 (C1551
default is 17)<br>
[7] - does nothing<br>

<p>The following table shows supported OPEN modes.

<table align=center border=1>
<tr><td>Mode<td>D64 <td>PC directory
<tr><td>Channel 0 (LOAD) <td>+ <td>+
<tr><td>Channel 0 ($) <td>+ <td>+
<tr><td>Channel 1 (SAVE) <td>+ <td>+
<tr><td>Channel 1 (SAVE@) <td>+ <td>+
<tr><td>Channels 2..14 R<td>+ <td>+
<tr><td>Channels 2..14 W @<td>+ <td>+
<tr><td>Channels 2..14 A<td>+ <td>+
<tr><td>Channels 2..14 M<td>- <td>-
<tr><td>Channels 2..14 L<td>+ <td>+
<tr><td>Channels 2..14 $<td>+ <td>+
<tr><td>Channel 15 (COMMAND) <td>+ <td>+
<tr><td>SEQ, PRG, USR files<td>+ <td>+
<tr><td>DEL files<td>+ <td>+
<tr><td>REL files<td>+ <td>+
<tr><td># (SET BUFFER)<td>+ <td>-
</table>

<a name=SND></a><h2 align=center>Sound</h2>

<p>The emulator can use three kinds of hardware for sound generation:

<ol>
<li>Standard PC speaker digital sound at 37287Hz;
<li>Adlib FM sound;
<li>Sound Blaster digital sound at 18643Hz. Direct mode is used, it is a
bit slow and therefore it requires at least 300Mhz CPU. The BLASTER environment variable
is required to set up the Sound Blaster hardware.
</ol>


<a name=VSS></a><h2 align=center>Video subsystem</h2>

<p>The following modes are supported

<table align=center border=1>
<tr><td>#<td>Hardware Resolution<td>C= Window Size<td>Video Card Type
<tr><td>0,7<td>320x200<td>320x200<td>VGA, VBE
<tr><td>1<td>320x240<td>320x240<td>VGA
<tr><td>2<td>320x350<td>320x288<td>VGA
<tr><td>3<td>320x400<td>320x288<td>VGA
<tr><td>4<td>360x240<td>352x240<td>VGA
<tr><td>5<td>360x400<td>352x288<td>VGA
<tr><td>6,8<td>400x300<td>368x288<td>Super VGA, VBE
<tr><td>9<td>640x400<td>368x288<td>VBE
<tr><td>10<td>640x480<td>368x288<td>VBE
</table>

<p>All these modes must be compatible with modern TFT-LCD monitors. Mode 0 
is set as default. The second mode number is VBE mode.


<a name=5></a><h2 align=center>Mouse</h2>

<table align=center>
<tr><td>Left button<td>-<td>Emulator's file system & options
<tr><td>Right button<td>-<td>exit to DOS
</table>



<a name=6></a><h2 align=center>ROMs</h2>

<p>The emulator can possibility to change/add any ROM-chip. When emulator
starts it looks for the next ROM-image files in the start-up directory:

<table align=center>
<tr><td>0<td>-<td>BASIC.ROM<td>-<td>BASIC ROM;
<tr><td>1<td>-<td>KERNAL.ROM<td>-<td>KERNAL ROM;
<tr><td>2<td>-<td>3P1_LO.ROM<td>-<td>3-PLUS-1 LOW ROM;
<tr><td>3<td>-<td>3P1_HI.ROM<td>-<td>3-PLUS-1 HIGH ROM;
<tr><td>4<td>-<td>C1_LO.ROM<td>-<td>CARTRIDGE #1 LOW ROM;
<tr><td>5<td>-<td>C1_HI.ROM<td>-<td>CARTRIDGE #1 HIGH ROM;
<tr><td>6<td>-<td>C2_LO.ROM<td>-<td>CARTRIDGE #2 LOW ROM;
<tr><td>7<td>-<td>C2_HI.ROM<td>-<td>CARTRIDGE #2 HIGH ROM;
<tr><td>8<td>-<td>C1551.ROM<td>-<td>C1551 ROM.
</table>

<p>Any of these files must have exactly 16KB length. If one or more of
such files are missed then standard (build-in in the emulator program
body) ROM contents will be used instead.

<p>Some ROM images on the Internet have 16386 bytes length (for unknown for
me reason 2 bytes added to theirs start) &mdash; remove first 2 bytes from
them.

<p>Make the separate directory for every cartridge ROM and then run the
emulator from the appropriate directory.

<p>It is more convinient way to use ROMs &mdash; specify ROM-filenames
in the <a href=#CLP>command line parameters</a>. The first column in the above
table indicates ROM-bank number.

      
<a name=7></a><h2 align=center>Main Features Of The Emulator</h2>

<p>It supports:

<table align=center>
<tr><td>-<td>CPU:
<tr><td><td>all standard opcodes <td>+
<tr><td><td>exact opcodes timing <td>+
<tr><td><td>decimal mode         <td>+
<tr><td><td>extra opcodes support<td>+
<tr><td><td>RMW instructions algorithm<td>+
<tr><td><td>build-in port             <td>%[1]
<tr><td><td>interrupts                <td>+
<tr><td>-<td>TED:
<tr><td><td>video                     <td>+[2]
<tr><td><td>sound                     <td>+[2][3]
<tr><td><td>timers                    <td>+
<tr><td><td>memory management         <td>+
<tr><td><td>interrupts                <td>+
<tr><td><td>keyboard                  <td>+
<tr><td><td>double/single clock       <td>+
<tr><td><td>exact CPU timing          <td>+
<tr><td>-<td>Parallel i/o chip (6529B)     <td>%[4]
<tr><td>-<td>Serial i/o chip (6551A)       <td>-
<tr><td>-<td>Keyboard                      <td>+
<tr><td>-<td>Joysticks                     <td>+
<tr><td>-<td>Serial Bus                    <td>-
<tr><td>-<td>Serial Bus devices            <td>-
<tr><td>-<td>C-1551 disk drives            <td>%[5]
<tr><td>-<td>Datasette                     <td>+
<tr><td>-<td>ROM cartridges (up to 64K)    <td>+
</table>

<p>[1] - full support of datasette lines only (Cassette Read/Write/Motor) and
bit 5 is always set to 0.<br>
[2] - 99% compatible.<br>
[3] - only for the PC speaker, Adlib or Sound Blaster compatible cards.
It's nearly impossible to produce digital sound effects with the
Adlib-cards family &mdash; use the PC Speaker or Sound Blaster to hear them.<br>
[4] - only the Cassette Sense line.<br>
[5] - Turbo-Loaders and some operations are still not supported.<br>

<p>Internal features of the emulator:

<ul>
<li>fast freeze/restore computer state (in the C2F format files);
<li>fast load/save/export/import programs and data from menus;
<li>support D64, PRG, P0n (S0n, D0n, R0n, U0n), TAP, and CTF (description see
below) formats;
<li>speed regulation;
<li>optional autoload of PRG-file during startup;
<li>build-in debugger with assembler/disassembler.
</ul>

<p>It can run only on a computer with the 80486 compatible CPU (at least the P200
is required for the 100% speed emulation, DPMI can reduce performance of the emulator
down more than twice, so use pure DOS for the maximum performance) and the VGA or VESA
compatible card.



<a name=8></a><h2 align=center>CPU JAM/HLT instructions</h2>

<p>The 'JAM' instructions work like hardware reset. If the Reset vector points on
any HLT type instruction then the emulator begins its meditation after the reset.



<a name=9></a><h2 align=center>I/O Ports Emulation</h2>

<table align=center>
<tr><td>FC00-FCFF<td>KERNAL ROM FIX          <td>+
<tr><td>FD00-FD0F<td>ACIA                    <td>-
<tr><td>FD10-FD1F<td>PIO                     <td>%[1]
<tr><td>FD30-FD3F<td>KEYBOARD MATRIX         <td>+
<tr><td>FDD0-FDDF<td>ROM CHIPS SELECTION PORT<td>+
<tr><td>FEC0-FEDF<td>IEC9/C1551              <td>+
<tr><td>FEE0-FEFF<td>IEC8/C1551              <td>+
</table>

<p>[1] - only Cassette Sense line.<br>



<a name=10></a><h2 align=center>TED Emulation</h2>

<table align=center border=1>
<tr><td>Index<td>Bit(s)<td>Function         <td>Emulation 
<tr><td>00<td>      0-7    <td>Timer 1 low byte <td>+
<tr><td>01<td>      0-7    <td>Timer 1 high byte<td>+
<tr><td>02<td>      0-7    <td>Timer 2 low byte <td>+
<tr><td>03<td>      0-7    <td>Timer 2 high byte<td>+
<tr><td>04<td>      0-7    <td>Timer 3 low byte <td>+
<tr><td>05<td>      0-7    <td>Timer 3 high byte<td>+
<tr><td>06<td>      0-2    <td>Screen Vertical Offset<td>+
<tr><td><td>    3      <td>0/1 - 24/25 rows    <td>+
<tr><td><td>    4      <td>0/1 - Screen off/on <td>+
<tr><td><td>    5      <td>0/1 - Bit Map off/on<td>+
<tr><td><td>    6      <td>0/1 - Extended color mode off/on<td>+
<tr><td><td>    7      <td>TEST                <td>-[2]
<tr><td>07<td>  0-2    <td>Screen Horizontal offset<td>+
<tr><td><td>    3      <td>0/1 - 38/40 columns <td>+
<tr><td><td>    4      <td>0/1 - Multicolor mode off/on<td>+
<tr><td><td>    5      <td>0/1 - Freeze off/on <td>-[2]
<tr><td><td>    6      <td>0/1 - PAL/NTSC      <td>-[2][1]
<tr><td><td>    7      <td>0/1 - Hardware reverse on/off<td>+
<tr><td>08<td>  0-7    <td>Keyboard/Joysticks latch<td>+
<tr><td>09<td>  0      <td>unused              <td>+
<tr><td><td>    1      <td>0/1 - Request for raster interrupt no/yes<td>+
<tr><td><td>    2      <td>0/1 - Request for light pen interrupt no/yes<td>?[4]
<tr><td><td>    3      <td>0/1 - Request for Timer 1 interrupt no/yes<td>+
<tr><td><td>    4      <td>0/1 - Request for Timer 2 interrupt no/yes<td>+
<tr><td><td>    5      <td>unused              <td>+
<tr><td><td>    6      <td>0/1 - Request for Timer 3 interrupt no/yes<td>+
<tr><td><td>    7      <td>0/1 - any TED interrupt request presents no/yes<td>+
<tr><td>0A<td>     0      <td>bit 8 raster interrupt set<td>+
<tr><td><td>    1      <td>0/1 - Mask raster interrupt yes/no<td>+
<tr><td><td>    2      <td>0/1 - Mask light pen interrupt yes/no<td>?[2]
<tr><td><td>    3      <td>0/1 - Mask Timer 1 interrupt yes/no<td>+
<tr><td><td>    4      <td>0/1 - Mask Timer 2 interrupt yes/no<td>+
<tr><td><td>    5      <td>unused                  <td>+
<tr><td><td>    6      <td>0/1 - Mask Timer 3 interrupt yes/no<td>+
<tr><td><td>    7      <td>unused                  <td>+
<tr><td>0B<td>  0-7    <td>raster interrupt set, bits 0-7<td>+
<tr><td>0C<td>  0-1    <td>bits 8-9 of cursor position<td>+
<tr><td><td>    2-7    <td>unused                  <td>+
<tr><td>0D<td>  0-7    <td>bits 0-7 of cursor position<td>+
<tr><td>0E<td>  0-7    <td>bits 0-7 of voice 2 frequency number<td>+
<tr><td>0F<td>  0-7    <td>bits 0-7 of voice 1 frequency number<td>+
<tr><td>10<td>  0-1    <td>bits 8-9 of voice 2 frequency number<td>+
<tr><td><td>    2-7    <td>unused                  <td>?[2]
<tr><td>11<td>  0-3    <td>Volume control (from 0 to 8)<td>+
<tr><td><td>    4      <td>Voice 1 select          <td>+
<tr><td><td>    5      <td>Voice 2 select          <td>+[5]
<tr><td><td>    6      <td>Voice 2 noise select    <td>+
<tr><td><td>    7      <td>Sound Reload            <td>+[6]
<tr><td>12<td>  0-1    <td>bits 8-9 of voice 1 frequency number<td>+
<tr><td><td>    2      <td>0/1 - Character generator or Bit map in RAM/ROM<td>+
<tr><td><td>    3-5    <td>bits 13-15 (other bits are equal to 0) of Bit map 
address<td>+
<tr><td><td>    6-7    <td>unused               <td>+
<tr><td>13<td>  0      <td>RAM/ROM status       <td>+
<tr><td><td>    1      <td>0/1 - Set CPU single clock for overscan off/on<td>+
<tr><td><td>    2      <td>bit 10 of Character generator address, it is usable 
only when bit 7 of register 7 (Hardware reverse) is set to 1<td>+
<tr><td><td>    3-7    <td>bits 11-15 (other bits are equal to 0) of character 
generator address<td>+
<tr><td>14<td>  0-2    <td>unused               <td>+
<tr><td><td>    3-7    <td>bits 11-15 (other bits are equal to 0) of color 
memory base<td>+
<tr><td>15<td>  0-3    <td>Color 1              <td>+
<tr><td><td>    4-6    <td>Luminance 1          <td>+
<tr><td><td>    7      <td>unused               <td>+
<tr><td>16<td>  0-3    <td>Color 2              <td>+
<tr><td><td>    4-6    <td>Luminance 2          <td>+
<tr><td><td>    7      <td>unused               <td>+
<tr><td>17<td>  0-3    <td>Color 3              <td>+
<tr><td><td>    4-6    <td>Luminance 3          <td>+
<tr><td><td>    7      <td>unused               <td>+
<tr><td>18<td>      0-3     <td>Color 4         <td>+
<tr><td><td>    4-6     <td>Luminance 4         <td>+
<tr><td><td>    7       <td>unused              <td>+
<tr><td>19<td>  0-3     <td>Overscan Color      <td>+
<tr><td><td>    4-6     <td>Overscan Luminance  <td>+
<tr><td><td>    7       <td>unused              <td>+
<tr><td>1A<td>      0-1     <td>bits 8-9 of current character position    <td>+
<tr><td><td>    2-7     <td>unused              <td>+
<tr><td>1B<td>      0-7     <td>bits 0-7 of current character position<td>+
<tr><td>1C<td>     0       <td>Vertical line bit 8     <td>+
<tr><td><td>    1-7     <td>unused              <td>+
<tr><td>1D<td>      0-7     <td>Vertical line bits 0-7  <td>+
<tr><td>1E<td>      0       <td>bit 0 of horizontal dot position  <td>%[4]
<tr><td><td>    1-7     <td>bits 1-7 of horizontal dot position      <td>+
<tr><td>1F<td>    0-2     <td>Vertical subaddress    <td>+
<tr><td><td>      3-6     <td>Blink counter          <td>+
<tr><td><td>    7       <td>unused                   <td>+
<tr><td>3E<td>             <td>Selects ROM           <td>+
<tr><td>3F<td>             <td>Selects RAM           <td>+
</table>

<p>[1] - always PAL.<br>
[2] - you may use this bit as ordinal RAM storage.<br>
[4] - always 0.<br>
[5] - bit 5 has higher priority than bit 6.<br>
[6] - its value 1 mutes both sound channels for the Adlib &mdash; for the PC speaker 
and Sound Blaster this bit is supported properly.<br>



<a name=11></a><h2 align=center>Commodore +4 main specifications</h2>

<ul>
<li>Commodore BASIC v3.5 (60671 byte free) with graphic, sound, disk i/o and
structural (like DO, LOOP, WHILE) commands;
<li>build-in machine language monitor with assembler/disassembler (accessed by
BASIC MONITOR command or (this allows to work without BASIC ROM-chip at
all!) holding pressed Run/Stop key during Reset or power-up);
<li>build-in text editor, spreadsheet and database;
<li>7501/8501 CPU (almost the same as 8502) at 0.9-1.8MHz (average CPU clock
  frequency depends on screen mode);
<li>121 colors palette;
<li>2 square-wave voice generators;
<li>320x200 graphic mode 121 colors, but only 2 colors in matrix 8x8[1];
<li>160x200 graphic mode 121 colors, but only 4 colors in matrix 4x8[1];
<li>40x25 text modes, 256 characters font;
<li>hardware reverse, extended graphics and multicolor modes extensions for
text mode;
<li>64KB RAM;
<li>64KB internal ROM and up to 64KB external ROM (cartridges);
<li>user port (parallel/centronics or serial/RS-232C with TTL logic up to
19200 bauds!);
<li>67 keys keyboard + reset button;
<li>2 digital joysticks (the typical Atari joystick logic but with the atypical smaller connector);
<li>datasette port (the same logic as for C-1530 but with another, smaller
connector);
<li>Commodore serial bus.
</ul>

<p>[1] - raster interrupts can make this limitation softer.<br>



<a name=12></a><h2 align=center>C+4 vs C64</h2>

<p>The C+4 and C64 are very similar, but the C64 achieved greater success.  The key difference?  The C64 was released more than a years earlier!  Below is a comparison table highlighting the main features of both machines.  Who comes out on top in this data competition?  Let's find out!

<table align=center border=1 style=border-color:green;border-width:thin;border-style:solid;border-spacing:0px>
<tr><th><th>C64 <th>C+4 <th>Notes

<tr><th colspan=4 align=center>BASIC
<tr><td>Version <td>2.0 <td>3.5 <td>
<tr><td>Free memory, bytes <td>38911 <td>60671 <td>
<tr><td>Total tokens <td>77 <td>128 <td>
<tr><td>DOS commands <td>- <td>+ <td>The C64 doesn't even have a command that shows directory contents.<br>
You have to load the contents as a file and then list it
<tr><td>Graphics commands <td>- <td>+ <td>
<tr><td>Structural commands <td>- <td>+ <td>
<tr><td>Sound commands <td>- <td>+ <td>
<tr><td>Joysticks commands <td>- <td>+ <td>
<tr><td>Garbage collection <td>worse <td>better <td>This requires 2 bytes more for every string on the C+4
<tr><td>Editor <td>worse <td>better <td>The C+4 has a set of ESC-commands that are implemented on the C128 too
<tr><td>Speed  <td colspan=3>In full screen modes the C64 is slightly faster than the C+4, but in the screen blank case the C+4 is much faster

<tr><th colspan=4 align=center>OTHER FIRMWARE
<tr><td>Build-in Monitor<br>with (dis)assembler <td>- <td>+ <td>
<tr><td>Build-in Full Screen<br>Text Editor, Spreadsheet<br>and DataBase <td>- <td>+ <td>The quality of the C+4 built-in software is good only for very small documents:<br>text notes and spreadsheets.

<tr><th colspan=4 align=center>HARDWARE
<tr><td>Effective CPU frequency<br>in standard screen mode,<br>MHz, PAL <td>0.933 <td>1.144 <td>≈123%
<tr><td>" NTSC <td>0.961 <td>1.046 <td>≈109%
<tr><td>Effective CPU frequency<br>in screen blank mode,<br>MHz, PAL <td>0.985 <td>1.7 <td>≈173%
<tr><td>" NTSC <td>1.023 <td>1.713 <td>≈167%
<tr><td>RAM Total <td>64K <td>64K <td>The C64 can use upto about 1.5 KB RAM more than the C+4<br>because of I/O holes and color RAM.<br>However the C+4 can get 1 KB gain when we use a user defined charset.<br>So in this case the C64 advantage is only about .5 KB, and if the C64 doesn't<br>use color RAM and uses a user defined charset then the C+4 can get .5 KB gain
<tr><td>I/O holes, byte <td>2(+4096)  <td>548  <td>C+4: CPU=2,IO=512(ACIA=16,PIO=16,KBD=16,<br>
MAGIC VOICE SOUND=16,ROMSEL=16),TED=34.<br>
C64: CPU=2,VIC=1024,SID=1024,VRAM=1024,CIA1=256,<br>
CIA2=256,EXP1/Z80=256,EXP2/DISK=256<br>
These holes (but CPU) reduce total usable RAM/ROM capacity on the C+4 only
<tr><td>ROM Total <td>2*8K+4K=20K <td>4*16K=64K <td>
<tr><td>ROM Max <td>5*8K+4K=44K <td>8*16K=128K <td>
<tr><td>CPU ports <td>6 <td>7 <td>They are the fastest
<tr><td>Serial Bus <td>+ <td>+ <td>
<tr><td>Digital Joysticks <td>2 <td>2 <td>
<tr><td>Paddles <td>4 <td>- <td>This allows to connect to the C64 up to 2 4-buttons<br>
analog joysticks (instead 2 digital) or the mouse
<tr><td>Datasette <td>1  <td>1 <td>
<tr><td>Fast C1551 drives <td>- <td>+ <td>These drives are connected directly to the CPU bus,<br>
the C64 theoretically can use similar drives.<br>This advantage became insignificant in the turbo loader epoch.<br>
But this was very important in the 80s

<tr><th colspan=4 align=center>User Port
<tr><td>Centronics <td>1 <td>1 <td rowspan=2>The C64 or C+4 can use only RS-232C or Centronics in the same time, but not both.<br>Not all standard Centronics or RS-232C signals are supported
<tr><td>TTL RS-232C <td>1 <td>1
<tr><td>Max. speed, bauds <td>300 <td>19200 <td>Special software enables the C64 to operate at speeds of up to 2400 baud
<tr><td>Synchro Serial Ports <td>2 <td>- <td>

<tr><th colspan=4 align=center>Keyboard
<tr><td>Total keys <td>66 <td>67+Reset <td>
<tr><td>Design <td>worse <td>better <td>The C+4 has separated cursor keys, the Esc key, and the doubled Control key.<br>The C64 has the Restore special key

<tr><th colspan=4 align=center>Graphics
<tr><td>Colors <td>16 <td>121 <td>
<tr><td>Hires Resolution <td>320x200 <td>320x200 <td>The C+4 can use more lines: 288 (PAL) and 232 (NTSC) or even more.<br>
The C64 may use sprites to extend the visible screen size. This allows,<br>for example to use 368x200 raster and even more
<tr><td>Multicolor Resolution <td>160x200 <td>160x200 <td>Similarly to the above, the C+4 can use more lines,<br>while the C64 can improve on this mode by adding sprites
<tr><td>Normal text mode <td>worse <td>better <td>The C+4 supports hardware flashing and more colors;<br>
it can also use more rows: 80 bytes per row.<br>
The C64 may use sprites to enhance this mode greatly
<tr><td>Hardware cursor <td>- <td>+ <td>
<tr><td>256 chars. on screen <td>worse <td>better <td>The C64 has limits on the use of the upper 128 chars:<br>
Kernal/Basic ROM assumes the reversed chars there
<tr><td>Hardware reverse <td>- <td>+  <td>This allows automatically to produce inverted
characters<br>
saving 2K characters ROM and removing limits on the upper 128 chars
<tr><td>Hardware flashing <td>- <td>+  <td>This consumes 1 bit of the color byte
<tr><td>Normal text mode,<br>
bytes per screen <td>1501 <td>2001 <td>C64: 1000 (chars) + 500 (foreground) + 1 (background)<br>
C+4: 1000 + 1000 + 1
<tr><td>Extended color text mode <td>+ <td>+ <td>
<tr><td>Extended color text mode,<br>
bytes per screen <td>1504 <td>2004 <td>C64: 1000 + 500 + 4 (ext. colors)<br>
C+4: 1000 + 1000 + 4
<tr><td>Multicolor text mode <td>+ <td>+ <td>Both computers reduce the number of colors from the background byte<br>
for a multicolor tile: C64 - 8 instead of 16, C+4 - 57 instead of 121.<br>
Similarly to the above, the C+4 can use more lines,<br>
while the C64 can improve on this mode by adding sprites
<tr><td>Multicolor text mode,<br>
bytes per screen <td>1503 <td>2003 <td>C64: 1000 + 500 + 3 (multicolors)<br>
C+4: 1000 + 1000 + 3
<tr><td>Hires Bitmap mode <td>+  <td>+ <td>
<tr><td>Hires Bitmap mode,<br>bytes per screen <td>9000 <td>10000 <td>C64: 8000 (bitmap) + 1000 (colors)<br>C+4: 8000 + 2000, the C+4 can use more lines: 400 bytes per 8 lines
<tr><td>Hires Bitmap mode,<br>dots per free color shape <td>32<td>32 <td>2 free colors in 8x8 matrix, 64/2<br>
The C64 can use sprites to add a lot of additional free colors
<tr><td>Hires Bitmap mode, average<br>number of colors per pixel <td>2.4375 <td>5.71875 <td>C64: (16*2+2*62)/64<br>C+4: (121*2+2*62)/64
<tr><td>Hires FLI-64/DFLI+4,<br>bytes per screen <td>16000 <td>16000 <td>8000 (bitmap) + 8000 (colors)<br>The C+4 can use more lines: 640 bytes per 8 lines
<tr><td>Hires FLI-64/DFLI+4,<br>dots per free color shape <td>4 <td>8 <td>C64: 2 free colors in the 8x1 matrix, 8/2<br>C+4: 2 free colors in the 8x2 matrix, 16/2<br>The C64 ability to use sprites is limited with FLI graphics
<tr><td>HR FLI-64/DFLI+4, average<br>number of colors per pixel <td>5.5 <td>16.875 <td>C64: (16*2+2*6)/8<br>C+4: (121*2+2*14)/16
<tr><td>Multicolor Bitmap mode <td>better <td>worse <td>
<tr><td>Multicolor Bitmap mode,<br>bytes per screen <td>9501 <td>10002 <td>C64: 8000 + 1000 + 500 (VRAM) + 1<br>C+4: 8000 + 2000 + 2, the C+4 can use more lines: 400 bytes per 8 lines
<tr><td>Multicolor Bitmap mode,<br>dots per free color shape <td>≈10.663 <td>≈15.984 <td>C64 free colors: 3 per 4x8 matrix + 1 per screen, 32000/3001<br>
C+4 free colors: 2 per 4x8 matrix + 2 per screen, 32000/2002<br>
The C64 can use sprites to add a lot of additional free colors
<tr><td>MC Bitmap mode, average<br>number of colors per pixel <td>5.125375 <td>11.3198125 <td>C64: (16*(1000*3+1)+4*(32000-3001))/32000<br>C+4: (121*(1000*2+2)+4*(32000-2002))/32000
<tr><td>Multicolor FLI-64/DFLI+4,<br>bytes per screen <td>16700 <td>16400 <td>C64: 8000 + 8*1000 + 500 (VRAM) + 200 (a color per line)<br>
C+4: 8000 + 4*2000 + 400 (2 colors per line)<br>
The C+4 can use more lines, 656 bytes per 8 lines
<tr><td>Multicolor FLI-64/DFLI+4,<br>dots per free color shape <td>≈1.86 <td>≈3.81 <td>C64 free colors: 2 per 4x1 matrix + 1 per 4x8 matrix + 1 per line, 1280/688<br>
C+4 free colors: 2 per 4x2 matrix + 2 per line, 320/84<br>
The C64 ability to use sprites is limited with FLI graphics
<tr><td>MC FLI-64/DFLI+4, average<br>number of colors per pixel <td>10.45 <td>34.7125 <td>C64: (16*(17*40+8)+4*(1280-688))/1280<br>C+4: (121*(2*40+4)+4*(320-84))/320
<tr><td>CPU cycles on a bad line<td>20/22 + 3 w/o<td>22 + 3 w/o<td>C64: no sprite fetches on this line, 22 - NTSC, 20 - PAL
<tr><td>Hardware scrolling <td>worse <td>better <td>
<tr><td>Color RAM <td>0.5K <td>- <td>This gives less free colors in multicolor bitmap mode for the C+4.<br>
Color RAM helps the C64 to handle video faster than the C+4<br> and increases free RAM storage for some modes<br>
(the C+4 takes 1K of main memory for keeping color information)
<tr><td>Hardware sprites <td>+ <td>- <td>The C64 can manage up to 8 24x21 sprites and even more,<br>
automatically detects their collisions, etc.<br> But every sprite makes the C64 CPU slightly slower

<tr><th colspan=4 align=center>Sound
<tr><td>Chip <td>SID <td>TED <td>The SID has been available for the +4 as an option
<tr><td>Channels <td>3 <td>2 <td>The C+4's second channel can produce either white noise or music
<tr><td>Frequency range <td>0-3.9KHz <td>109Hz-110KHz <td>
<tr><td>Wave forms <td>wide range <td>square only <td>The SID can produce various different types<br>
of special sound effects and high quality music synthesis

<tr><th colspan=4 align=center>Time
<tr><td>2-bytes timers <td>4 <td>3 <td>The C64 timers have wider range of working<br>modes than on the C+4
<tr><td>4-bytes RTC <td>2 <td>- <td>They are actually pseudo-RTC because they don't have a battery.

<tr><th colspan=4 align=center>Interrupts
<tr><td>NMI <td>+ <td>- <td>
<tr><td>IRQ <td>+ <td>+ <td>
<tr><td>Reset <td>worse <td>better <td> The C64 has no usable Reset switch, the C+4 has one
<tr><td>Cassette Read/<br>
Serial Bus SRQ  <td>1  <td>- <td rowspan=8>      The C64 has 14 types of interrupt sources: the Restore key (1, NMI),<br> VIC-II (4, IRQ), CIA1 (5, IRQ) and CIA2 (4, NMI); the C+4 has 6 types<br> of internal interrupt sources: the TED (5) and ACIA (1)
<tr><td>Timers <td>4 <td>3       
<tr><td>RTC <td>1 <td>-       
<tr><td>Raster <td>1 <td>1       
<tr><td>Sprite's <td>2 <td>-       
<tr><td>Synchro Serial Ports <td>2 <td>-       
<tr><td>Light Pen <td>1 <td>1       
<tr><td>RS-232C <td>1 <td>1       
</table>

<p>The C64 has fewer colors, but they are more flexible.  This allows more dithering.  And this can significantly offset the C64 disadvantage compared to the C+4.

<p>The C+4 may also use Hires FLI graphics using 2 free colors in the 8x1 matrix but this fixes 16 colors for the whole screen and therefore reducing number of colors from 121 maximum.  This mode gives the same average number of colors per pixel as on the C64 and requires 16040 bytes per 320x200 screen, 640 bytes per 8 lines plus 40 bytes for the initialization.  The C+4 may also use Multicolor FLI graphics using 2 free colors in the 4x1 matrix but this again fixes 16 colors for the whole screen reducing total number of colors from 121 maximum.  The Multicolor FLI graphics keeps the two additional free colors free from this limitation allowing to use any of 121 colors.  So this mode gives (16*80+121*2+4*(160-82))/160 = 11.4625 for the average number of colors per pixel having 160/82 ≈ 1.951 for dots per free color shape.  This mode requires 16440 bytes per 160x200 screen.  These modes have been used very rarely and not properly documented.

<p>The FLI/DFLI graphics requires some code to support it, about 20 bytes per line.

<p>The C+4 can control the raster very flexibly, for example, you can add visible lines by reducing the refresh rate of the screen, or vice versa, you can increase the refresh rate by reducing the number of lines.  By controlling the raster, you can also move the screen up or down.

<p>The C+4 can use interlacing graphics that doubles the number of raster lines.  Some programs use this.  But this feature is still not documented.  

<p>The C+4 PAL can use PAL inverted colors that gives upto 112 additional colors and that gives resulting 233 colors total!

<p>The C+4 PAL can be switched to NTSC mode.  This unfortunately breaks the video signal but speeds up the CPU to 2.22 MHz!  The effective frequency is slightly lower, at approximately 2.12 MHz when the screen is blank.  Nonetheless, this renders the C+4 faster than any other known 8-bit computer.

<p>So, the C+4 has a faster CPU, an enhanced BASIC with DOS commands, a better editor and keyboard, a good ML monitor, better hardware scrolling, a much faster RS-232C port, slightly better normal text mode, many more colors, more ROM and a resizable screen (1-29/36 rows on NTSC/PAL; fewer rows means the faster CPU).  It also has better handling of 256 characters.

<p>The C64 has typically slightly more usable RAM, slightly better multicolor bitmap mode, hardware sprites and much better synthesized music.  It also supports the paddles and the mouse!  The sprites offer a variety of additional capabilities.  The C64 also has more timers, which are more advanced, but this doesn't rather offer any practical advantages.

<p>It seems that the digital sound quality of both machines is almost identical.

<p>Finally, it should be mentioned that the C64 has more software and hardware while the C+4 has been much cheaper since 1986.  But the C+4 (or C264) could have been much cheaper since 1984 and if this had happened then we could have had something completely different in the amount of hardware and software available for this computer.  Moreover, Commodore ceased supporting the C+4 in 1985 and this had dramatic consequences for this computer: no more official software releases, etc.

<p>Interestingly that the C+4 PAL is generally more advanced than the C+4 NTSC while the C64 NTSC is only slightly better (a bit faster, few more CPU cycles per line) than the C64 PAL.

<p>Special thanks to Epy who helped to fix an error.

<a name=13></a><h2 align=center>Debugger</h2>

<p>It's a functional copy of the MS-DOS DEBUGGER. It has almost the same
commands set (see table below).</p>

<table align=center>
<tr><td>Function<td>MS-DOS<br>debugger<br>commands<td>Emulator<br>commands
<td>Emulation
<tr><td>Assemble<td>A <td>A <td>+
<tr><td>Compare <td>C <td>C <td>+
<tr><td>Dump    <td>D <td>D <td>+
<tr><td>Enter   <td>E <td>E <td>+[1]
<tr><td>Fill    <td>F <td>F <td>+[1]
<tr><td>Go      <td>G <td>G <td>+[6]
<tr><td>Go Line <td>&lt;miss&gt;<td>GL<td>![6][10]
<tr><td>Hex     <td>H <td>H <td>+
<tr><td>Load    <td>L <td>L <td>+
<tr><td>Move    <td>M <td>M <td>+
<tr><td>Name    <td>N <td>N <td>+
<tr><td>watchpOint<td>&lt;miss&gt;<td>O <td>![7]
<tr><td>Proceed <td>P <td>P <td>+[3][6]
<tr><td>Quit    <td>Q <td>Q <td>+[4]
<tr><td>Register<td>R <td>R <td>+[12]
<tr><td>Search  <td>S <td>S <td>+[1]
<tr><td>Trace   <td>T <td>T <td>+[5]
<tr><td>Unassemble<td>U<td>U<td>+
<tr><td>View    <td>&lt;miss&gt;<td>V  <td>![2]
<tr><td>Write   <td>W <td>W <td>+
<tr><td>cYcle of TED<td>&lt;miss&gt;<td>Y<td>![11]
<tr><td>eXtra   <td>&lt;miss&gt; <td>X <td>![14]
<tr><td>Zoom    <td>&lt;miss&gt; <td>Z <td>![8]
<tr><td>?       <td>? <td>? <td>+
<tr><td>!       <td><td>!<td>![9]
</table>

<p>[1] - It doesn't support string literals (i.e. this command supports only 
hex literals).<br>
[2] - It shows the plus/4 screen.<br>
[3] - This command is equivalent of G (Go) command with a breakpoint set to the
next assembler instruction, it is very useful for fast tracing
subroutines (JSR) and back loops (BNE, BEQ, ...). Using P for tracing the JMP
instruction or forward conditional branches has no viewable sense.<br>
[4] - It returns to the emulator and turns it to the non-debugger mode.<br>
[5] - This command outputs the time of the instruction(s) execution. It hides
interrupts during its execution but the interrupt execution time is displayed.
Some interrupt handlers may change interrupt return point &mdash; this may
throw T-command into an endless loop &mdash; press F9 in this case.<br>
[6] - After these commands the emulator turns into debugger mode. In this mode F9
causes to return to the last debugger screen.<br>
[7] - It has the same syntax as the G command but instead of breakpoints it sets
watchpoints (they break the program execution if any byte at the given
addresses is rewritten).<br>
[8] - It selects 25 or 50 rows debugger mode.<br>
[9] - Immediate exit from the emulator.<br>
[10] - It breaks the execution at a given line.<br>
[11] - This command is TED oriented &mdash; it invokes special mode of the
debugger &mdash; any other command returns the debugger to normal mode<br>
[12] - It also shows LINE (TED 1C & 1D registers pair value), POS (TED 1E
register) and 2CPU (cycles performed by CPU for current instruction).<br>
[14] - This command shows internal TED and emulated video display values,
hardware vectors, and TED registers.<br>

<p>Breakpoint(s) and watchpoint(s) set by G (Go), GL (Go Line), P (Proceed),
or O (Watchpoint) commands slow the emulator but only on several percents.

<p>It uses the next mnemonics for (un)assemble CPU commands:

<pre>
    BRK               ;00           NOP2    #$nn      ;80
    ORA     ($nn,X)   ;01           STA     ($nn,X)   ;81
    JAM               ;02           NOP2    #$nn      ;82
    ASLORA  ($nn,X)   ;03           STXSTA  ($nn,X)   ;83
    NOP2    $nn       ;04           STY     $nn       ;84
    ORA     $nn       ;05           STA     $nn       ;85
    ASL     $nn       ;06           STX     $nn       ;86
    ASLORA  $nn       ;07           STXSTA  $nn       ;87
    PHP               ;08           DEY               ;88
    ORA     #$nn      ;09           NOP2    #$nn      ;89
    ASL               ;0A           TXA               ;8A
    ANC     #$nn      ;0B           TXAAND  #$nn      ;8B
    NOP3    $nnnn     ;0C           STY     $nnnn     ;8C
    ORA     $nnnn     ;0D           STA     $nnnn     ;8D
    ASL     $nnnn     ;0E           STX     $nnnn     ;8E
    ASLORA  $nnnn     ;0F           STXSTA  $nnnn     ;8F
    BPL     $nnnn     ;10           BCC     $nnnn     ;90
    ORA     ($nn),Y   ;11           STA     ($nn),Y   ;91
    JAM               ;12           JAM               ;92
    ASLORA  ($nn),Y   ;13           SHA     ($nn),Y   ;93
    NOP2    $nn,X     ;14           STY     $nn,X     ;94
    ORA     $nn,X     ;15           STA     $nn,X     ;95
    ASL     $nn,X     ;16           STX     $nn,Y     ;96
    ASLORA  $nn,X     ;17           STXSTA  $nn,Y     ;97
    CLC               ;18           TYA               ;98
    ORA     $nnnn,Y   ;19           STA     $nnnn,Y   ;99
    NOP1              ;1A           TXS               ;9A
    ASLORA  $nnnn,Y   ;1B           SHS     $nnnn,Y   ;9B
    NOP2    $nnnn,X   ;1C           SHY     $nnnn,X   ;9C
    ORA     $nnnn,X   ;1D           STA     $nnnn,X   ;9D
    ASL     $nnnn,X   ;1E           SHX     $nnnn,Y   ;9E
    ASLORA  $nnnn,X   ;1F           SHA     $nnnn,Y   ;9F
    JSR     $nnnn     ;20           LDY     #$nn      ;A0
    AND     ($nn,X)   ;21           LDA     ($nn,X)   ;A1
    JAM               ;22           LDX     #$nn      ;A2
    ROLAND  ($nn,X)   ;23           LDXLDA  ($nn,X)   ;A3
    BIT     $nn       ;24           LDY     $nn       ;A4
    AND     $nn       ;25           LDA     $nn       ;A5
    ROL     $nn       ;26           LDX     $nn       ;A6
    ROLAND  $nn       ;27           LDXLDA  $nn       ;A7
    PLP               ;28           TAY               ;A8
    AND     #$nn      ;29           LDA     #$nn      ;A9
    ROL               ;2A           TAX               ;AA
    ANC     #$nn      ;2B           LXA     #$nn      ;AB
    BIT     $nnnn     ;2C           LDY     $nnnn     ;AC
    AND     $nnnn     ;2D           LDA     $nnnn     ;AD
    ROL     $nnnn     ;2E           LDX     $nnnn     ;AE
    ROLAND  $nnnn     ;2F           LDXLDA  $nnnn     ;AF
    BMI     $nnnn     ;30           BCS     $nnnn     ;B0
    AND     ($nn),Y   ;31           LDA     ($nn),Y   ;B1
    JAM               ;32           JAM               ;B2
    ROLAND  ($nn),Y   ;33           LDXLDA  ($nn),Y   ;B3
    NOP2    $nn,X     ;34           LDY     $nn,X     ;B4
    AND     $nn,X     ;35           LDA     $nn,X     ;B5
    ROL     $nn,X     ;36           LDX     $nn,Y     ;B6
    ROLAND  $nn,X     ;37           LDXLDA  $nn,Y     ;B7
    SEC               ;38           CLV               ;B8
    AND     $nnnn,Y   ;39           LDA     $nnnn,Y   ;B9
    NOP1              ;3A           TSX               ;BA
    ROLAND  $nnnn,Y   ;3B           LAS     $nnnn,Y   ;BB
    NOP3    $nnnn,X   ;3C           LDY     $nnnn,X   ;BC
    AND     $nnnn,X   ;3D           LDA     $nnnn,X   ;BD
    ROL     $nnnn,X   ;3E           LDX     $nnnn,Y   ;BE
    ROLAND  $nnnn,X   ;3F           LDXLDA  $nnnn,Y   ;BF
    RTI               ;40           CPY     #$nn      ;C0
    EOR     ($nn,X)   ;41           CMP     ($nn,X)   ;C1
    JAM               ;42           NOP2    #$nn      ;C2
    LSREOR  ($nn,X)   ;43           DECCMP  ($nn,X)   ;C3
    NOP2    $nn       ;44           CPY     $nn       ;C4
    EOR     $nn       ;45           CMP     $nn       ;C5
    LSR     $nn       ;46           DEC     $nn       ;C6
    LSREOR  $nn       ;47           DECCMP  $nn       ;C7
    PHA               ;48           INY               ;C8
    EOR     #$nn      ;49           CMP     #$nn      ;C9
    LSR               ;4A           DEX               ;CA
    ANDLSR  #$nn      ;4B           SBX     #$nn      ;CB
    JMP     $nnnn     ;4C           CPY     $nnnn     ;CC
    EOR     $nnnn     ;4D           CMP     $nnnn     ;CD
    LSR     $nnnn     ;4E           DEC     $nnnn     ;CE
    LSREOR  $nnnn     ;4F           DECCMP  $nnnn     ;CF
    BVC     $nnnn     ;50           BNE     $nnnn     ;D0
    EOR     ($nn),Y   ;51           CMP     ($nn),Y   ;D1
    JAM               ;52           JAM               ;D2
    LSREOR  ($nn),Y   ;53           DECCMP  ($nn),Y   ;D3
    NOP2    $nn,X     ;54           NOP2    $nn,X     ;D4
    EOR     $nn,X     ;55           CMP     $nn,X     ;D5
    LSR     $nn,X     ;56           DEC     $nn,X     ;D6
    LSREOR  $nn,X     ;57           DECCMP  $nn,X     ;D7
    CLI               ;58           CLD               ;D8
    EOR     $nnnn,Y   ;59           CMP     $nnnn,Y   ;D9
    NOP1              ;5A           NOP1              ;DA
    LSREOR  $nnnn,Y   ;5B           DECCMP  $nnnn,Y   ;DB
    NOP2    $nnnn,X   ;5C           NOP3    $nnnn,X   ;DC
    EOR     $nnnn,X   ;5D           CMP     $nnnn,X   ;DD
    LSR     $nnnn,X   ;5E           DEC     $nnnn,X   ;DE
    LSREOR  $nnnn,X   ;5F           DECCMP  $nnnn,X   ;DF
    RTS               ;60           CPX     #$nn      ;E0
    ADC     ($nn,X)   ;61           SBC     ($nn,X)   ;E1
    JAM               ;62           NOP2    #$nn      ;E2
    RORADC  ($nn,X)   ;63           INCSBC  ($nn,X)   ;E3
    NOP2    $nn       ;64           CPX     $nn       ;E4
    ADC     $nn       ;65           SBC     $nn       ;E5
    ROR     $nn       ;66           INC     $nn       ;E6
    RORADC  $nn       ;67           INCSBC  $nn       ;E7
    PLA               ;68           INX               ;E8
    ADC     #$nn      ;69           SBC     #$nn      ;E9
    ROR               ;6A           NOP               ;EA
    ANDROR  #$nn      ;6B           SBC     #$nn      ;EB
    JMP     ($nnnn)   ;6C           CPX     $nnnn     ;EC
    ADC     $nnnn     ;6D           SBC     $nnnn     ;ED
    ROR     $nnnn     ;6E           INC     $nnnn     ;EE
    RORADC  $nnnn     ;6F           INCSBC  $nnnn     ;EF
    BVS     $nnnn     ;70           BEQ     $nnnn     ;F0
    ADC     ($nn),Y   ;71           SBC     ($nn),Y   ;F1
    JAM               ;72           JAM               ;F2
    RORADC  ($nn),Y   ;73           INCSBC  ($nn),Y   ;F3
    NOP2    $nn,X     ;74           NOP2    $nn,X     ;F4
    ADC     $nn,X     ;75           SBC     $nn,X     ;F5
    ROR     $nn,X     ;76           INC     $nn,X     ;F6
    RORADC  $nn,X     ;77           INCSBC  $nn,X     ;F7
    SEI               ;78           SED               ;F8
    ADC     $nnnn,Y   ;79           SBC     $nnnn,Y   ;F9
    NOP1              ;7A           NOP1              ;FA
    RORADC  $nnnn,Y   ;7B           INCSBC  $nnnn,Y   ;FB
    NOP3    $nnnn,X   ;7C           NOP3    $nnnn,X   ;FC
    ADC     $nnnn,X   ;7D           SBC     $nnnn,X   ;FD
    ROR     $nnnn,X   ;7E           INC     $nnnn,X   ;FE
    RORADC  $nnnn,X   ;7F           INCSBC  $nnnn,X   ;FF
</pre>

<p>You must enter all 2 or 4 digits in operands: don't miss leading zero(s)!
This limitation is only applicable for entering the 8501 assembler mnemonics, not
debugger commands. All spaces are ignored in the entered mnemonics between
its natural delimiters (comma, brackets, $, #), e.g. you may enter: BNE$0672,
LDA # $ 01, etc.). Some instructions (NOP1, NOP2, JAM, etc.) have the same
mnemonics and operands structure: during assembling the minimal appropriate
opcode is gotten.

<p>The debugger uses command line editor which is built-in in any DOS
core: thus you may use F1, F2, F3, F4, F5, Insert, Delete, Esc,
and BackSpace keys for edit in any kind of DOS. You may also use ^C
(Control-C) and ^S (Control-S) keys during the text output. Some DOSes have
extended command line editors or command like HISTORY.COM which can extend
features of the editor.

<p>If you want to save some debugger disassembler or dump output in a file,
you may use the standard DOS streams redirection technique, e.g.<br>
&nbsp;&nbsp;<code>PLUS4 &lt;CMDS &gt;LISTING</code><br>
will start the normal emulator execution but after F9 all input will go from the
CMDS file and all the output will send to LISTING. The CMDS file must consists of
the debugger commands (one command per line) and the last line in it ought to
be Q.

<p>The debugger correctly works with PRG and supports pure binary formats (with
some other formats it can work as with the pure binaries).

<p>NOTE! The i/o menus are not available from the debugger, i.e. during
execution G, O, or P commands.



<a name=14></a><h2 align=center>CPU and TED Timing</h2>

<p>Since version of 1.32 of the emulator the timing becomes 99.9% exact. Most FLI
demos must work.

<p>The emulator maximum frame rate is limited (for synchronization with the
real plus/4) to approximately 50.3Hz (it's possible to change emulator
speed).



<a name=15></a><h2 align=center>Datasette Emulation</h2>

<p>The CTF format is the best (at least for now) for the emulation of
datasette. It has some features that even let a CTF-file to look slightly better
than a real cassette.

<p>Before the cassette read, you can place the datasette head exactly on the desired
block (using menus). After reading the last block on the tape, the head automatically
moves to the position of the first block (= auto rewind).

<p>The datasette automatically moves head to the start of the tape free space
when the write operation begins. After writing the head is placed on
the start of the first block on the tape.

<p>WARNING!!! Activation of the tape motor not for i/o operations and then
making attempt to access to the Commodore serial bus may produce a block of
garbage on the tape (this situation is fully adequate the real one: press play
& record on the real datasette with the tape then try to access to the serial
bus and you get some unsense noise on the cassette) or a block starting
with garbage (this block may not be recognized in menus). To evade these small
inconveniences press PLAY (& RECORD) on tape (the Scroll Lock button on the PC
keyboard) only after appropriate prompts.

<p>The TAP format is also supported but for the read operations only.


<a name=16></a><h2 align=center>Menus</h2>

<p>Menus are accessible only when the debugger is off. They provide a lot of
useful features missed on the real plus/4: freeze/restore the current
computer state (e.g. save game in any moment), device manipulations, fast
load/save and export/import data and programs, etc.

<p>'Size' column shows size depend on image file type: in bytes for the CTF
files and in blocks for the D64 files.

<p>If in the 'Type' column for a block of a CTF file is placed '?' (and
the appropriate size is equal to 0) then this means that this block is a
turbo-block or a garbage-block.

<p>Menus support the mouse.



<a name=17></a><h2 align=center>CTF Format</h2>

<p>CTF &mdash; Commodore Tape File. It was developed before the TAP format appeared.
The CTF is 100% real cassette compatible (like TAP) and provides some
structural information which allows to move the head position to the beginning
of every tape block (like T64). CTF has unlimited capacity. T64, unlike CTF,
doesn't reflect the block nature of the CBM method used for
writing on the tape. For example, it can't work with data files (via OPEN,
PRINT#, CLOSE, ...) and turbo loaders and savers.

<p>It's easy to convert T64 to CTF or CTF to TAP. Backward conversion is not
formal and requires some AI. It's nearly impossible to convert the general CTF or
TAP data to the T64 format. The conversion from TAP to CTF is much easier.
The CTF-file size is several times smaller than for the same data in the TAP
format.

<p>TAP is only the intermediate format to transfer data from the real tapes.
It is the best for its fields but if you want to feel the taste of the full
scaled job with datasette (data files, turbo savers, ...) then use CTF!
Utility CTF2TAP may always convert CTF-file to the TAP form.

<p>The table below shows CTF-file structure.</p>

<pre>
OFFSET  NAME            LENGTH  COMMENTS
0       FORMAT VERSION   2      0 FOR VERSION 1.xx OF THE EMULATOR
2       HEAD POSITION    2      HEAD POINTS ON THE TAPE'S BLOCK WITH THIS
                                NUMBER
4       CAPACITY         2      QUANTITY OF BLOCKS+1 ON THE TAPE
6       BLOCK #1 POINTER
        (TO THE END OF
        THIS BLOCK +1)   4      THE POINTER CONTAINS ABSOLUTE FILE
                                POSITION (NNNN)
0AH     TIME CONSTANT    1      DURATION (IN TED TICKS) OF HALF-PERIOD OF
                                MAXIMUM FREQUENCY WAVES
0BH     DATA             ?
NNNN    BLOCK #2 POINTER 4      LAST BLOCK POINTER POINTS TO END OF FILE
NNNN+4  BLOCK #2 TIME
        CONSTANT         1
        ...
</pre>

<p>Data at offset 0BH consist of bits which are value in the CPU datasette
port through fixed time periods (the time constant at 0AH is equal to this period).

<p>The standard Commodore 264 tape block starts and ends with the gap of max
frequency waves. Each byte of the information has the next structure:

<p>[SM][B1][B2][B3][B4][B5][B6][B7][B8][B9];<br>
[SM]=[T2][T1];<br>
[Bn]=[T0][T1], if [Bn]=0;<br>
[Bn]=[T1][T0], if [Bn]=1.<br>

<p>[SM] - Start of byte Marker, [Bn] - Bit of information number <em>n</em>, 
[T0] - a max. frequency (=F<sub>0</sub>) period, [T1] - a period with 
frequency 2*F<sub>0</sub>, [T2] - a period with frequency 4*F<sub>0</sub>. 
[B9] - a parity bit, odd parity is used. Last byte
of block of data contains XOR of all previous bytes. Each block is written to
tape two times (with gap between them). The next nine bytes precede a block
first time: 89h, 88h, .. 81h; and the next nine bytes precede a block second
time: 9, 8, ..1.

<p>Therefore each byte of data on the tape in the standard Commodore 264 format
occupies (9*6+12)*2=132bits=16.5 bytes. The length of block in CTF file (in
standard format) is approximately equal to [start gap length =4096]+[gap
between blocks length =110]+[end gap length =49]+16.5*([length of block]+10).
Many of turbo savers (like NOVALOAD) may produce less than 3 bytes per
each saved byte in a CTF file.

<p>Each block (except the program body block) in the standard Commodore 264 tape
format after 9 marker bytes contains the type specification byte, e.g.:

<p>1 - standard (BASIC) program header (next block loaded at $1001)<br>
2 - data block (created by PRINT# or CLOSE)<br>
3 - machine code program header (next block loaded at a given address)<br>
4 - header of the data file (created by OPEN)<br>
5 - End Of Tape (EOT) marker block.<br>
 


<a name=18></a><h2 align=center>C2F Format</h2>

<p>C2F - Commodore 264 Freeze format. The table below shows its structure.</p>

<pre>
OFFSET  AREA NAME       LENGTH  COMMENTS

------- FORMAT SPECIFICATION -----------
0       VERSION         2       1 SINCE VERSION 1.10 OF THE EMULATOR

------- ADDITIONAL INFORMATION ---------
2       CPU TIME        1       TICKS TO CPU (UNUSED SINCE VER. 1.32)

------- CPU REGISTERS ------------------
3       PC              2
5       SP              2       HIGH BYTE = 1
7       XR              2       HIGH BYTE = 0
9       YR              2       HIGH BYTE = 0
0BH     SR              1
0CH     AC              1

------- CPU PORTS ----------------------
0DH     $0              1
0EH     $1              1

------- MEMORY CONFIGURATION -----------
0FH     ROMMAP          1
10H                     1       BITS 0-1 - SOUND HARDWARE (0-PC,
                                  1-Adlib, 2-None, 3-Sound Blaster)
                                BITS 2-4 - JOYSTICK2 HARDWARE
                                  (0-K1, 1-K2, 2-J1, 3-J2, 4-None)
                                BITS 5-7 - JOYSTICK1 HARDWARE

------- TED ----------------------------
11H     TIMER #1 RELOAD
        VALUE           2

------- ADDITIONAL INFORMATION ---------
13H     LED             1       KBD LED INDICATOR DATA - CapsLock, Play,
                                   and Record buttons state

------- TED ----------------------------
14H     TED REGISTERS   20H(32)

------- RAM ----------------------------
34H     $2-$FFFF        0FFFEH(65534)
</pre>


<a name=CFG></a><h2 align=center>CFG file format</h2>

<p>First byte is a <a href=#VSS>video mode number</a> multiplied by 2,
second byte is a frame skipping determinant (1 &mdash; no skips, 3 &mdash;
to skip 2/3 of frames, 5 &mdash; to skip 4/5 of frames, etc.), third byte
determines sound card (0 &mdash; PC Speaker, 1 &mdash; Adlib, 2 &mdash; no
sound; 3 &mdash; Sound Blaster).

<p>PLUS4.CFG is the name of the CFG-file.

<p>It is also possible to load CFG-file with any name (and CFG extension)
from the command line.


<a name=CLP></a><h2 align=center>Command Line Parameters</h2>

<p>It is possible to use up to 12 parameters at the command line &mdash; the
names of PRG/P0n/D64/CTF/TAP/C2F/ROM/CFG-files. These files will be automatically loaded/attached during the emulator's startup.

<p>Example.<br>
<code>plus4 a.prg x\b.prg c.p01 e.d64 f.tap</code><br>
will load `a', `b' (from subdirectory `x'), and `c' programs into memory,
attach disk image `e' to device 8, and attach tape image `f'.

<p>It is possible to set exact device number for d64-image by `/8' (default)
or `/9' prefix.

<p>So <code>plus4 e.d64 /9g.d64</code>,<br>
will attach disk image `e' to device 8 and disk image `g' to device 9.

<p>Within the parameters list, it is possible to set working directory. This
setting will affect all followed relative filesystem addresses. The working
directory may be set several times in one list of parameters.

<p>Example.<br>
<code>plus4 c:\cplus4\d64\ disk.d64 /9..\d2.d64 d:\ cbm\a.prg</code><br>
will set working directory, attach `disk.d64' from it, attach `d2.d64' from
`c:\cplus4\', set new working directory, and load `a.prg' from `d:\cbm\'.

<p>NOTE! Do not omit extension for any file name. The working directory must
be ended by `\'. The order of parameters is important &mdash; the next
parameter may override the effect of the previous one.

<p>The name of the ROM-image file may be preceded by /N, where N is
ROM-bank number (<a href=#6>to see the table</a>). The default number is 4.

<p>Example.<br>
<code>plus4 c:\crt\c16tutor\ c16tutor_1.rom /5c16tutor2.rom</code>,<br>
will load two ROM-images to banks 4 and 5.

<p>It is also possible to set video mode via appropriate parameter. Use
`#vid' form to set <a href=#VSS>video mode #</a>.<br>
<code>plus4 1vid</code><br>
should set video mode to 320x240 &mdash; this setting will override default
CFG-file setting. The number should be hexadecimal, so you have to use `A'
instead of 10.

<p>The sound hardware may be set in the same way. Use `#snd' form to set it.
The numbers are the same as in <a href=#CFG>CFG</a> or <a href=#18>C2F</a>
files.

<p>Example.<br>
<code>plus4 1snd</code><br>
selects Adlib card.

<p>The option ? (question mark) may be used to show summary of the command line
parameters.


<a name=19></a><h2 align=center>Compilation</h2>

<p>You need <a href=http://fasm.sourceforge.net/>FASM</a> V1.67 or newer for
sources compilation.

<p>Command<br> `<code>fasm plus4.asm</code>'<br> creates the emulator
executable file. Use FASM under the pure DOS (without memory managers like 
EMM386) or with DPMI services or under any Linux.

<p>You must have C+4 ROM images files BASIC.ROM (16K), KERNAL.ROM (16K),
3P1.ROM (32K), and 1551.ROM (16K) in the directory which contains CV
subdirectory during compilation. The third and fourth files are unnecessary
and may contain anything.


<a name=20></a><h2 align=center>(C) Copyright</h2> 

<p>Almost all data and program files of this package are written by
V.Lidovski in the X/1996-IV/1997;VI-VIII,XII/1998;IV/2000;XI/2002;
VII-VIII/2003;II,V-VIII,X,XII/2004;VI-VIII,XI,XII/2005;I,V,VII-VIII/2006;
I-III,VIII,XII/2007;I,VIII/2008, VI/2024.

<p>All source code is Copyright (C) 1997-2008,2024,2025 Vladimir Lidovski. This program
is distributed under the GNU General Public License, Version 2, or, at your
discretion, any later version. The GNU General Public License is available
via the Web <a href=http://www.gnu.org/copyleft/gpl.html>here</a>. The GPL is 
designed to allow you to alter and redistribute the package, as long as you 
do not remove that freedom from others.



<a name=BUG></a><h2 align=center>BUGS REPORTS</h2>

<p>Please send messages about any discovered bugs to author's email &mdash;
litwr@yandex.ru.



<a name=21></a><h2 align=center>History and the last updates</h2>

<p>The first version of this emulator was finally compiled on the 9th of April
of 1997. It was uploaded to <a href=https://www.zimmers.net/anonftp/pub/cbm/crossplatform/emulators/msdos/index.html>ftp.funet.fi</a> on the 30th of June of 1997.

<p>The <em>changes list history</em> is <a href=plus4chl.htm>here</a>.

<p>v1.43 Beta has been developing since 2024, its sources are available at <a href=https://github.com/litwr2/retro/tree/main/plus4/plus4-forever-qm>github</a>.

</body>
</html>

