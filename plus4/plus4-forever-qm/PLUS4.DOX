  Commodore Plus/4 Emulator `Forever' v1.19 information



   CONTENTS        

+  Preview
+  OS
+  Used IBM hardware resources
+  Keyboard
+  Joysticks
+  Mouse
+  ROMs
+  Main Features Of The Emulator
+  CPU JAM instructions
+  I/O Ports Emulation
+  TED Emulation
+  Commodore +4 main specifications
+  C+4 vs C64
+  Debugger
+  CPU and TED Timing
+  Datasette Emulation
+  Menus
+  CTF Format
+  C2F Format
+  Compilation
+  (C) Copyright
+  Changes List



  Preview

  I think I've created an unique emulator, because I've never seen any
Commodore plus/4 (16 or 116) since March 1991... This version of the
emulator has created only from some my old and found in Internet
documentation (`c64doc' v1.8 by John West and Marko Makela, `Extra
Instructions Of The 65XX Series CPU' by Adam Vardy...) and some advices
from Attila Grosz. It's written only in 100% 80486 assembler (16-bit mode).



  OS

  Reprogramming the timer hardware made impossible to run the
emulator from Microsoft Windows environment - use DOS or Windows 95/98/Me
DOS mode. For NT/2000/XP users: creation a DOS boot disk (or CD-ROM) is
only a possibility to run this program.




  Used IBM hardware resources

  The emulator completely takes-over interrupt 9 (keyboard) and intercepts
interrupt 8. The emulator uses only base DOS memory. Screen size is 320x207.
It has direct access to the following ports: 20-21 (programmable interrupt
controller); 40, 43 (timer hardware -- to set IRQ0 frequency to 37287Hz);
60 (keyboard); 201 (joysticks); 388-389 (Ad Lib); 3CE-3CF (VGA).
  ATTENTION! Video memory at address range A0000-B02C0 is used. If the
emulator runs with UMB managers like EMM386 then be sure that range
B000-B07F is closed for UMB.
 
  

  Keyboard

  Some keys description:
Alt             - Commodore key
Tab             - Run/Stop
F5              - Change sound hardware (beeper, adlib, none)
F9              - Debugger
F10             - Exit to DOS (power off button)
F11             - Reset button
F12             - Emulator's file system & options
Scroll Lock     - Button Play on the datasette
Num Lock        - Button Record on the datasette (press only it when message
                  "PRESS PLAY & RECORD ON TAPE" appeared)
SysRq (Alt+PrintScreen) - Immediate exit to DOS (Warning! It can interrupt
                  any operation, e.g. with file)

  If you want to leave a program which changes Reset vector then you need to
exit from the emulator or to load a C2F image.



  Joysticks

  You can use any combination of real analog joysticks and the keyboard keys
for joystick emulation. There are two keys sets for the emulation:
  KEYS1 - Word Star like - SEDX/;
  KEYS2 - cursors and right shift keys.



  Mouse

  Left button   - Emulator's file system & options
  Right button  - exit to DOS



  ROMs

  The emulator can possibility to change/add any ROM-chip. When emulator
starts it looks for the next ROM-image files in start-up directory:
  BASIC.ROM     - BASIC ROM;
  KERNAL.ROM    - KERNAL ROM;
  3P1_LO.ROM    - 3-PLUS-1 LOW ROM;
  3P1_HI.ROM    - 3-PLUS-1 HIGH ROM;
  C1_LO.ROM     - CARTRIDGE #1 LOW ROM;
  C1_HI.ROM     - CARTRIDGE #1 HIGH ROM;
  C2_LO.ROM     - CARTRIDGE #2 LOW ROM;
  C2_HI.ROM     - CARTRIDGE #2 HIGH ROM.
  Any of these files must have exact 16KB length. If one or more of the such
files were missed then standard (build-in in the emulator program body) ROM
contents was used instead.
  Some ROM images in the Internet have 16386 bytes length (for unknown for
me reason 2 bytes added to theirs start) - remove first 2 bytes from them.
  Make the separate directory for every cartrige ROM and then run the
emulator from the appropriate directory.


      
  Main Features Of The Emulator

  It supports:
- CPU:
   all standard opcodes         +
   exact opcodes timing         +
   decimal mode                 +[4]
   extra opcodes support        +
   RMW instructions algorithm   +
   build-in port                %[1]
   interrupts                   +
- TED:
   video                        +[2]
   sound                        +[2][3]
   timers                       +
   memory management            +
   interrupts                   +
   keyboard                     +
   double/single clock          +[2]
- Parallel i/o chip (6529B)     %[5]
- Serial i/o chip (6551A)       -
- Keyboard                      +
- Joysticks                     +
- Serial Bus                    -
- Serial Bus devices            -
- C-1551 disk drives            -
- Datasette                     +
- ROM cartridges (up to 64K)    +

[1] - full support of datasette lines only (Cassette Read/Write/Motor).
[2] - 98% compatible.
[3] - only for PC speaker or Adlib compatible cards (e.g. any Sound Blaster).
      It's nearly impossible to produce digital sound effects on the
      Adlib-cards family -- use Speaker sound to hear them.
[4] - according general 6502 family standard.
[5] - only Cassette Sense line.

  Internal features of the emulator:
- fast freeze/restore computer state (in the C2F format files);
- fast load/save/export/import programs and data from menus;
- support D64, PRG, P0n (S0n, D0n, R0n, U0n) and CTF (description see below)
  formats;
- speed regulation;
- build-in powerful debugger with assembler/disassembler.

  It can run only on computer with 80486 compatible CPU (at least P166 is
required for 100% speed emulation) and VGA compatible card.



  CPU JAM instructions

  JAM instructions work like hardware reset. If Reset vector points on any
JAM type instruction then after reset the emulator begins meditation.



  I/O Ports Emulation

FC00-FCFF       KERNAL ROM FIX          %[1]
FD00-FD0F       ACIA                    -
FD10-FD1F       PIO                     %[2]
FD30-FD3F       KEYBOARD MATRIX         +
FDD0-FDDF       ROM CHIPS SELECTION
                PORT                    +
FEC0-FEDF       IEC9/C1551              -
FEE0-FEFF       IEC8/C1551              -

[1] - only for CPU access.
[2] - only Cassette Sense line.



  TED Emulation

Index   Bit(s)  Function                Emulation  Description
00      0-7     Timer 1 low byte        +
01      0-7     Timer 1 high byte       +
02      0-7     Timer 2 low byte        +
03      0-7     Timer 2 high byte       +
04      0-7     Timer 3 low byte        +
05      0-7     Timer 3 high byte       +
06      0-2     Screen Vertical
                Offset                  +
        3       0/1 - 24/25 rows        +
        4       0/1 - Screen off/on     +
        5       0/1 - Bit Map off/on    +
        6       0/1 - Extended color
                mode off/on             +
        7       TEST                    -[2]
07      0-2     Screen Horizontal
                offset                  +
        3       0/1 - 38/40 columns     +
        4       0/1 - Multicolor mode
                off/on                  +
        5       0/1 - Freeze off/on     +
        6       0/1 - PAL/NTSC          -[2][1]
        7       0/1 - Hardware
                reverse on/off          +
08      0-7     Keyboard/Joysticks      
                latch                   +
09      0       unused                  ?[3]
        1       0/1 - Request for
                raster interrupt
                no/yes                  +
        2       0/1 - Request for
                light pen interrupt
                no/yes                  ?[3]
        3       0/1 - Request for
                Timer 1 interrupt
                no/yes                  +
        4       0/1 - Request for
                Timer 2 interrupt
                no/yes                  +
        5       unused                  ?[3]
        6       0/1 - Request for
                Timer 3 interrupt
                no/yes                  +
        7       0/1 - any TED
                interrupt request
                presents no/yes         +
0A      0       bit 8 raster
                interrupt set           +
        1       0/1 - Mask raster
                interrupt yes/no        +
        2       0/1 - Mask light pen
                interrupt yes/no        ?[2]
        3       0/1 - Mask Timer 1
                1 interrupt yes/no      +
        4       0/1 - Mask Timer 2
                interrupt no/yes        +
        5       unused                  ?[2]
        6       0/1 - Mask Timer 3
                interrupt no/yes        +
        7       unused                  ?[2]
0B      0-7     raster interrupt
                set, bits 0-7           +
0C      0-1     bits 8-9 of cursor
                position                +
        2-7     unused                  +[4]
0D      0-7     bits 0-7 of cursor
                position                +
0E      0-7     bits 0-7 of voice 2
                frequency number        +
0F      0-7     bits 0-7 of voice 1
                frequency number        +
10      0-1     bits 8-9 of voice 2
                frequency number        +
        2-7     unused                  ?[2]
11      0-3     Volume control (from
                0 to 8)                 +
        4       Voice 1 select          +
        5       Voice 2 select          +[5]
        6       Voice 2 noise select    +
        7       Sound Reload            +[6]
12      0-1     bits 8-9 of voice 1
                frequency number        +
        2       0/1 - Character
                generator or Bit map
                in RAM/ROM              +
        3-5     bits 13-15 (other
                bits are equal to 0)
                of Bit map address      +
        6-7     unused                  ?[2]
13      0       RAM/ROM status          +
        1       0/1 - Set CPU single
                clock for overscan
                off/on                  +
        2       bit 10 of Character
                generator address, it
                is usable only when
                bit 7 of register 7
                (Hardware reverse)
                is set to 1             +
        3-7     bits 11-15 (other
                bits are equal to 0)
                of Character generator
                address                 +
14      0-2     unused                  ?[2]
        3-7     bits 11-15 (other
                bits are equal to 0)
                of Color memory base    +
15      0-3     Color 1                 +
        4-6     Luminance 1             +
        7       unused                  ?[2]
16      0-3     Color 2                 +
        4-6     Luminance 2             +
        7       unused                  ?[2]
17      0-3     Color 3                 +
        4-6     Luminance 3             +
        7       unused                  ?[2]
18      0-3     Color 4                 +
        4-6     Luminance 4             +
        7       unused                  ?[2]
19      0-3     Overscan Color          +
        4-6     Overscan Luminance      +
        7       unused                  ?[2]
1A      0-1     bits 8-9 of current
                character position      +
        2-7     unused                  +[4]
1B      0-7     bits 0-7 of current
                character position      +
1C      0       Vertical line bit 8     +
        1-7     always are 1            +
1D      0-7     Vertical line bits 0-7  +
1E      0-1     bits 1-2 of horizontal
                dot position            %[3]
        2-7     bits 3-8 of horizontal
                dot position            +
1F      0-3     Blink counter           +
        4-6     Vertical subaddress     ?
        7       unused                  ?[3]
3E      ?       Selects ROM             +
3F      ?       Selects RAM             +

[1] - always PAL.
[2] - you may use this bit as ordinal RAM storage.
[3] - they have pseudo random value.
[4] - it's always set to one.
[5] - bit 5 has higher priority than bit 6.
[6] - its value 1 mutes both sound channels for Adlib - for PC speaker this
      bit supported properly.



  Commodore +4 main specifications

- Commodore BASIC v3.5 (60671 byte free) with graphic, sound, disk i/o and
  structural (like DO, LOOP, WHILE) commands;
- build-in machine language monitor with assembler/disassembler (accessed by
  BASIC MONITOR command or (this allows to work without BASIC ROM-chip at
  all!) holding pressed Run/Stop key during Reset or power-up);
- build-in text editor, spreadsheet and database;
- 7501/8501 CPU (almost the same as 8502) at 0.9-1.8MHz (average CPU clock
  frequency depends on screen mode);
- 121 colors palette;
- 2 square-wave voice generators;
- 320x200 graphic mode 121 colors, but only 2 colors in matrix 8x8[1];
- 160x200 graphic mode 121 colors, but only 4 colors in matrix 4x8[1];
- 40x25 text modes, 256 characters font;
- hardware reverse, extended graphics and multicolor modes extensions for
  text mode;
- 64KB RAM;
- 64KB internal ROM and up to 64KB external ROM (cartridges);
- user port (parallel/centronics or serial/RS-232C with TTL logic up to
  19200 bauds!);
- 67 keys keyboard + reset button;
- 2 digital joysticks;
- datasette port (the same logic as for C-1530 but with another, smaller
  connector);
- Commodore serial bus.

[1] - raster interrupts can make this limitation softer.



  C+4 vs C64

  C+4 and C64 are very similar. Why does success come only for C64?
  I think it is only one answer: C64 is two years elder! Below I place a
table with quality/quantity comparison of the main features of both machines.
Who has won this data competition?...

                            C64     C+4     Notes

  BASIC
   Version                  2.0     3.5
   Free memory, bytes       38911   60671
   Total tokens             77      128
   Special disk commands    -       +
   Graphics commands        -       +
   Structural commands      -       +
   Sound commands           -       +
   Joysticks commands       -       +

  Build-in Monitor
    with (dis)assembler     -       +

  Build-in Full Screen Text
    Editor, Spreadsheet
    and DataBase            -       +

  Speed                     =       =       In full screen modes C64 is some
                                            faster than C+4, but in screen
                                            blank case C+4 is faster
  RAM
   Total                    64K     64K
   I/O holes size, byte     4098    578     C+4: CPU=2,IO=576(ACIA=16,PIO=16,
                                                 KBD=16,MAGIC VOICE SOUND=16,
                                                 ROMSEL=16,IEC8=32,IEC9=32,
                                                 TED=34).
                                            C64: CPU=2,VIC=1024,SID=1024,
                                                 VRAM=1024,CIA1=256,CIA2=256,
                                                 EXP1/Z80=256,EXP2/DISK=256
                                            * These holes reduce total usable
                                            RAM capacity!

  ROM
   Total                    2*8K+4K 4*16K   C+4 can work only with one 16K
                            =20K    =64K    Kernal ROM and use other 3 16K
                                            ROM slots in any manner (e.g. to
                                            view/save any ROM chip content!)
   Max                      3*8K+4K 8*16K
                            =28K    =128K
  Keyboard
   Total keys               66      67+Reset
   Reset button             -       +
   Design                   worse   better

  Graphics
   Colors                   16      121
   Max. Resolution          320x200 320x200
   Extended mode            +       +
   Multicolor mode          +       +
   Bit Map Mode             +       +
   Hardware cursor          -       +
   256 chars. on screen     +       +
   Hardware reverse         -       +       This allows automatically to
                                            produce inverted characters
                                            saving 2K characters ROM!
   38/40 columns modes      +       +
   24/25 rows modes         +       +
   X/Y-scrolling            +       +
   Fixed color RAM          +       -       This makes C+4 more flexible
   Color RAM                0.5K    -       Color RAM helps C64 be some 
                                            faster than C+4 in the text 
                                            modes, and increases free RAM 
                                            storage for some modes
                                            (C+4 takes 1K of main memory
                                            for keeping color information)
   Hardware sprites         +       -       C64 can manage up to 8 24x21
                                            sprites, automatically detects
                                            there collisions, etc.
   
  Sound
   Channels                 3       2       C+4's second channel can produce
                                            either white noise or music
   Frequency range          0-      109Hz-
                             3.9KHz  110KHz
   Wave forms               wide    square  C64 can produce various different
                            range   only    types of special sound effects
                                            and high quality music synthesis

  Time
   2-bytes timers           4       3       C64 timers have wider range of
                                            working modes than on C+4
   4-bytes RTC              2       -

  Interrupts
   NMI                      +       -
   IRQ                      +       +
   Reset                    worse   better  C64 has no simple user usable
                                            Reset switch, C+4 has one
   Interrupts sources
    Cassette Read/
     Serial Bus SRQ         1       -       C64 has 13 types of interrupt
    Timers                  4       3       sources: 4 from VIC, 5 from CIA1
    RTC                     1       -       and 4 from CIA2 - VIC (IRQ),
    Raster                  1       1       CIA1 (IRQ) and CIA2 (NMI) can
    Sprite's                2       -       produce only one interrupt signal;
    Synchro Serial Port     2       -       each C+4 has 6 types of interrupt
    Light Pen               1       1       sources: 5 from TED and 1 from
    RS-232C                 1       1       ACIA - TED and ACIA can each
                                            produce only one IRQ signal

  Serial Bus                +       +       C+4 doesn't support SRQ line

  Digital Joysticks         2       2

  Paddles                   4       -       This allows to connect to C64
                                            up to 2 4-buttons analog
                                            joysticks (instead 2 digital)

  User Port
   Centronics               1       1       C64 and C+4 can use only RS-232C
   TTL RS-232C              1       1       or Centronics in the same time,
     Max. speed, bauds      300     19200   but not both
   Synchro Serial Ports     2       -

  Datasette                 1       1

  Fast C1551 drives         -       +       These drives connected directly to
                                            the CPU bus, C64 theoretically can
                                            use similar drives...



  Debugger

  It's a functional copy of the MS-DOS DEBUGGER. It has almost the same
commands set (see table below).

           MS-DOS   Commodore
Function  debugger  plus/4 e.  Emulation
          commands  commands

Assemble     A         A       +
Compare      C         C       +
Dump         D         D       +
Enter        E         E       +[1]
Fill         F         F       +[1]
Go           G         G       +[6]
Hex          H         H       +
Load         L         L       +
Move         M         M       +
Name         N         N       +
watchpOint   O         O       ![7]
Proceed      P         P       +[3][6]
Quit         Q         Q       +[4]
Register     R         R       +
Search       S         S       +[1]
Trace        T         T       +[5]
Unassemble   U         U       +
View       <miss>      V       !, shows the plus/4 screen
Write        W         W       +
Zoom       <miss>      Z       !, selects 25 or 50 rows debugger mode.
?            ?         ?       +
       
[1] - It doesn't support string literals (i.e. this command supports only hex
      literals).
[3] - This command is equivalent of G (Go) command with breakpoint set to the
      next assembler instruction, it is very useful for fast tracing
      subroutines (JSR) and loops (BNE, BEQ, ...). Using P for trace JMP
      instruction and alike generally has no viewable sense.
[4] - It returns to the emulator and turns emulator in the non-debugger mode.
[5] - This command outputs time of instruction(s) execution.
[6] - After these commands emulator turns into debugger mode. In this mode F9
      causes to return to last debugger screen.
[7] - It has the same syntax as G command but instead of breakpoints it sets
      watchpoints (they break program execution if any byte at given
      addresses is rewritten).

  Breakpoint(s) and watchpoint(s) set by G (Go), P (Proceed), or O
(Watchpoint) commands slow the emulator but only on several percent.
  It uses the next mnemonics for (un)assemble CPU commands:

    BRK               ;00           NOP2    #$nn      ;80
    ORA     ($nn,X)   ;01           STA     ($nn,X)   ;81
    JAM               ;02           NOP2    #$nn      ;82
    ASLORA  ($nn,X)   ;03           STXSTA  ($nn,X)   ;83
    NOP2    $nn       ;04           STY     $nn       ;84
    ORA     $nn       ;05           STA     $nn       ;85
    ASL     $nn       ;06           STX     $nn       ;86
    ASLORA  $nn       ;07           STXSTA  $nn       ;87
    PHP               ;08           DEY               ;88
    ORA     #$nn      ;09           NOP2    #$nn      ;89
    ASL               ;0A           TXA               ;8A
    ANC     #$nn      ;0B           TXAAND  #$nn      ;8B
    NOP3    $nnnn     ;0C           STY     $nnnn     ;8C
    ORA     $nnnn     ;0D           STA     $nnnn     ;8D
    ASL     $nnnn     ;0E           STX     $nnnn     ;8E
    ASLORA  $nnnn     ;0F           STXSTA  $nnnn     ;8F
    BPL     $nnnn     ;10           BCC     $nnnn     ;90
    ORA     ($nn),Y   ;11           STA     ($nn),Y   ;91
    JAM               ;12           JAM               ;92
    ASLORA  ($nn),Y   ;13           SHA     ($nn),Y   ;93
    NOP2    $nn,X     ;14           STY     $nn,X     ;94
    ORA     $nn,X     ;15           STA     $nn,X     ;95
    ASL     $nn,X     ;16           STX     $nn,Y     ;96
    ASLORA  $nn,X     ;17           STXSTA  $nn,Y     ;97
    CLC               ;18           TYA               ;98
    ORA     $nnnn,Y   ;19           STA     $nnnn,Y   ;99
    NOP1              ;1A           TXS               ;9A
    ASLORA  $nnnn,Y   ;1B           SHS     $nnnn,Y   ;9B
    NOP2    $nnnn,X   ;1C           SHY     $nnnn,X   ;9C
    ORA     $nnnn,X   ;1D           STA     $nnnn,X   ;9D
    ASL     $nnnn,X   ;1E           SHX     $nnnn,Y   ;9E
    ASLORA  $nnnn,X   ;1F           SHA     $nnnn,Y   ;9F
    JSR     $nnnn     ;20           LDY     #$nn      ;A0
    AND     ($nn,X)   ;21           LDA     ($nn,X)   ;A1
    JAM               ;22           LDX     #$nn      ;A2
    ROLAND  ($nn,X)   ;23           LDXLDA  ($nn,X)   ;A3
    BIT     $nn       ;24           LDY     $nn       ;A4
    AND     $nn       ;25           LDA     $nn       ;A5
    ROL     $nn       ;26           LDX     $nn       ;A6
    ROLAND  $nn       ;27           LDXLDA  $nn       ;A7
    PLP               ;28           TAY               ;A8
    AND     #$nn      ;29           LDA     #$nn      ;A9
    ROL               ;2A           TAX               ;AA
    ANC     #$nn      ;2B           LXA     #$nn      ;AB
    BIT     $nnnn     ;2C           LDY     $nnnn     ;AC
    AND     $nnnn     ;2D           LDA     $nnnn     ;AD
    ROL     $nnnn     ;2E           LDX     $nnnn     ;AE
    ROLAND  $nnnn     ;2F           LDXLDA  $nnnn     ;AF
    BMI     $nnnn     ;30           BCS     $nnnn     ;B0
    AND     ($nn),Y   ;31           LDA     ($nn),Y   ;B1
    JAM               ;32           JAM               ;B2
    ROLAND  ($nn),Y   ;33           LDXLDA  ($nn),Y   ;B3
    NOP2    $nn,X     ;34           LDY     $nn,X     ;B4
    AND     $nn,X     ;35           LDA     $nn,X     ;B5
    ROL     $nn,X     ;36           LDX     $nn,Y     ;B6
    ROLAND  $nn,X     ;37           LDXLDA  $nn,Y     ;B7
    SEC               ;38           CLV               ;B8
    AND     $nnnn,Y   ;39           LDA     $nnnn,Y   ;B9
    NOP1              ;3A           TSX               ;BA
    ROLAND  $nnnn,Y   ;3B           LAS     $nnnn,Y   ;BB
    NOP3    $nnnn,X   ;3C           LDY     $nnnn,X   ;BC
    AND     $nnnn,X   ;3D           LDA     $nnnn,X   ;BD
    ROL     $nnnn,X   ;3E           LDX     $nnnn,Y   ;BE
    ROLAND  $nnnn,X   ;3F           LDXLDA  $nnnn,Y   ;BF
    RTI               ;40           CPY     #$nn      ;C0
    EOR     ($nn,X)   ;41           CMP     ($nn,X)   ;C1
    JAM               ;42           NOP2    #$nn      ;C2
    LSREOR  ($nn,X)   ;43           DECCMP  ($nn,X)   ;C3
    NOP2    $nn       ;44           CPY     $nn       ;C4
    EOR     $nn       ;45           CMP     $nn       ;C5
    LSR     $nn       ;46           DEC     $nn       ;C6
    LSREOR  $nn       ;47           DECCMP  $nn       ;C7
    PHA               ;48           INY               ;C8
    EOR     #$nn      ;49           CMP     #$nn      ;C9
    LSR               ;4A           DEX               ;CA
    ANDLSR  #$nn      ;4B           SBX     #$nn      ;CB
    JMP     $nnnn     ;4C           CPY     $nnnn     ;CC
    EOR     $nnnn     ;4D           CMP     $nnnn     ;CD
    LSR     $nnnn     ;4E           DEC     $nnnn     ;CE
    LSREOR  $nnnn     ;4F           DECCMP  $nnnn     ;CF
    BVC     $nnnn     ;50           BNE     $nnnn     ;D0
    EOR     ($nn),Y   ;51           CMP     ($nn),Y   ;D1
    JAM               ;52           JAM               ;D2
    LSREOR  ($nn),Y   ;53           DECCMP  ($nn),Y   ;D3
    NOP2    $nn,X     ;54           NOP2    $nn,X     ;D4
    EOR     $nn,X     ;55           CMP     $nn,X     ;D5
    LSR     $nn,X     ;56           DEC     $nn,X     ;D6
    LSREOR  $nn,X     ;57           DECCMP  $nn,X     ;D7
    CLI               ;58           CLD               ;D8
    EOR     $nnnn,Y   ;59           CMP     $nnnn,Y   ;D9
    NOP1              ;5A           NOP1              ;DA
    LSREOR  $nnnn,Y   ;5B           DECCMP  $nnnn,Y   ;DB
    NOP2    $nnnn,X   ;5C           NOP3    $nnnn,X   ;DC
    EOR     $nnnn,X   ;5D           CMP     $nnnn,X   ;DD
    LSR     $nnnn,X   ;5E           DEC     $nnnn,X   ;DE
    LSREOR  $nnnn,X   ;5F           DECCMP  $nnnn,X   ;DF
    RTS               ;60           CPX     #$nn      ;E0
    ADC     ($nn,X)   ;61           SBC     ($nn,X)   ;E1
    JAM               ;62           NOP2    #$nn      ;E2
    RORADC  ($nn,X)   ;63           INCSBC  ($nn,X)   ;E3
    NOP2    $nn       ;64           CPX     $nn       ;E4
    ADC     $nn       ;65           SBC     $nn       ;E5
    ROR     $nn       ;66           INC     $nn       ;E6
    RORADC  $nn       ;67           INCSBC  $nn       ;E7
    PLA               ;68           INX               ;E8
    ADC     #$nn      ;69           SBC     #$nn      ;E9
    ROR               ;6A           NOP               ;EA
    ANDROR  #$nn      ;6B           SBC     #$nn      ;EB
    JMP     ($nnnn)   ;6C           CPX     $nnnn     ;EC
    ADC     $nnnn     ;6D           SBC     $nnnn     ;ED
    ROR     $nnnn     ;6E           INC     $nnnn     ;EE
    RORADC  $nnnn     ;6F           INCSBC  $nnnn     ;EF
    BVS     $nnnn     ;70           BEQ     $nnnn     ;F0
    ADC     ($nn),Y   ;71           SBC     ($nn),Y   ;F1
    JAM               ;72           JAM               ;F2
    RORADC  ($nn),Y   ;73           INCSBC  ($nn),Y   ;F3
    NOP2    $nn,X     ;74           NOP2    $nn,X     ;F4
    ADC     $nn,X     ;75           SBC     $nn,X     ;F5
    ROR     $nn,X     ;76           INC     $nn,X     ;F6
    RORADC  $nn,X     ;77           INCSBC  $nn,X     ;F7
    SEI               ;78           SED               ;F8
    ADC     $nnnn,Y   ;79           SBC     $nnnn,Y   ;F9
    NOP1              ;7A           NOP1              ;FA
    RORADC  $nnnn,Y   ;7B           INCSBC  $nnnn,Y   ;FB
    NOP3    $nnnn,X   ;7C           NOP3    $nnnn,X   ;FC
    ADC     $nnnn,X   ;7D           SBC     $nnnn,X   ;FD
    ROR     $nnnn,X   ;7E           INC     $nnnn,X   ;FE
    RORADC  $nnnn,X   ;7F           INCSBC  $nnnn,X   ;FF

  You must enter all 2 or 4 digits in operands: don't miss leading zero(s)!
This limitation is only applicable for entering 8501 assembler mnemonics, not
debugger commands. All spaces are ignored in the entered mnemonics between
its natural delimiters (comma, brackets, $, #), e.g. you may enter: BNE$0672,
LDA # $ 01, etc.). Some instructions (NOP1, NOP2, JAM, etc.) have the same
mnemonics and operands structure: during assembling the minimal appropriate
opcode is gotten.
  The debugger has simple editor which is the same as DOS command line
editor: thus you may use F1, F2, F3, F4, F5, Insert, Delete, Esc and
BackSpace keys for edit. You may also use ^C (Control-C) and ^S (Control-S)
keys during text output.
  If you want to save some debugger disassembler or dump output in a file,
you may use standard DOS streams redirection technique, e.g.
    PLUS4 <CMDS >LISTING
will start normal emulator execution but after F9 all input will get from
CMDS file and all output will send to LISTING. CMDS file must consists of
debugger's commands (one command per a line) and last line in it ought to
be Q.
  The debugger correct works with PRG and supports pure binary formats (with
some other formats it can work as with pure binaries).
  NOTE! The i/o menus are not available from the debugger, i.e. during
execution G, O, or P commands.



  CPU and TED Timing

  I'm sorry, I don't implement exact system timing scheme. Below I describe
the scheme which is used in this emulator.
  TED screen consists of 312 raster lines which contains 57 character
position. TED provides for CPU standard single frequency if it operate with
character screen area and it provides double frequency for CPU when it
displays overscan area (only if bit 1 of TED 13 register is set to 0).
  This scheme is not accurate.
  The emulator maximum frame rate is limited (for synchronization with the
real plus/4) to approximately 50.3Hz (it's possible to change emulator
speed).



  Datasette Emulation

  The CTF files are only format supported for the emulated datasette. They
have some features, which let them to look some better than real cassettes.
  Before cassette read, you can place datasette's head exactly on desired
block (using menus). After reading last block on tape, head automatically
moved to the position of the first block (= auto rewind), that useful during
searching.
  The datasette automatically moves head to the start of the tape's free space
when you write something on the cassette. After writing the head is placed on
the start of first block on tape.
  WARNING!!! Activation of the tape motor not for i/o operation and then
making attempt to access to the Commodore serial bus may produce a block of
garbage on the tape (this situation is fully adequate the real one: press play
& record on the real datasette with the tape then try to access to the serial
bus and you get some unsense noise on the cassette...) or a block starting
with garbage (this block may not be recognized in menus). To evade these small
inconveniences press PLAY (& RECORD) on tape (Scroll Lock button on the PC
keyboard) only after appropriate prompts.



  Menus

  Menus accessible only when datasette motor (or PLAY button) and debugger's
breakpoints are off. They provide a lot of the useful features missed on real
plus/4: freeze/restore current computer state (= save game in any moment!),
devices manipulation, fast load/save and export/import data and programs, etc.
  'Size' column shows size depend on image file type: in bytes for CTF files
and in the blocks for D64 ones.
  If in 'Type' column for a block of a CTF file placed '?' (and appropriate
size is equal to 0) then this means that this block is a turbo-block or
garbage-block.
  Menus support mouse.



  CTF Format

  CTF - Commodore Tape File. I use this format instead of T64 because it
provides space for some additional important information and has unlimited
capacity. The T64 doesn't reflect the block nature of CBM method used for
writing on the tape. For example, it can't work with data file (via OPEN,
PRINT# and CLOSE) and turbo loaders and savers. The CTF format is 98% real
cassette compatible! The table below shows CTF-file structure.

OFFSET  NAME            LENGTH  COMMENTS
0       FORMAT VERSION   2      0 FOR VERSION 1.xx OF THE EMULATOR
2       HEAD POSITION    2      HEAD POINTS ON THE TAPE'S BLOCK WITH THIS
                                NUMBER
4       CAPACITY         2      QUANTITY OF BLOCKS+1 ON THE TAPE
6       BLOCK #1 POINTER
        TO THE END OF
        THIS BLOCK +1    4      THE POINTER CONTAINS ABSOLUTE FILE
                                POSITION (NNNN)
0AH     TIME CONSTANT    1      DURATION (IN TED TICKS) OF HALF-PERIOD OF
                                MAXIMUM FREQUENCY WAVES
0BH     DATA             ?
NNNN    BLOCK #2 POINTER 4      LAST BLOCK POINTER POINTS TO END OF FILE
NNNN+4  BLOCK #2 TIME
        CONSTANT         1
        <...>

  Data at offset 0BH consist of bits which are value in the CPU datasette
port through fix time periods (time constant at 0AH is half of this period).
  Standard Commodore 264 tape block starts and ends with gap from max
frequency waves. Each byte of the information has the next structure:
        <SM><B1><B2><B3><B4><B5><B6><B7><B8><B9>;
        <SM>=<T2><T1>;
        <Bn>=<T0><T1>, if <Bn>=0;
        <Bn>=<T1><T0>, if <Bn>=1.
  <SM> - Start of byte Marker, <Bn> - Bit of information number <n>, <T0> - a
max. frequency (=F0) period, <T1> - a period with frequency 2*F0, <T2> - a
period with frequency 4*F0. <B9> - a parity bit, odd parity is used. Last byte
of block of data contains XOR of all previous bytes. Each block is written to
tape two times (with gap between them). The next nine bytes precede a block
first time: 89h, 88h, .. 81h; and the next nine bytes precede a block second
time: 9, 8, ..1.
  Therefore each byte of data on the tape in standard Commodore 264 format
occupies (9*6+12)*2=132bits=16.5bytes. The length of block in CTF file (in
standard format) is approximately equal to <start gap length =4096>+<gap
between blocks length =110>+<end gap length =49>+16.5*(<length of block>+10).
Many of the turbo savers (like NOVALOAD) may produce less than 3 bytes per
each saved byte in a CTF file.
  Each block (except program body block) in standard Commodore 264 tape format
after 9 marker bytes contains type specification byte, e.g.:
  1 - standard (BASIC) program header (next block loaded at $1001)
  2 - data block (created by PRINT# or CLOSE)
  3 - machine code program header (next block loaded at a given address)
  4 - header of the data file (created by OPEN)
  5 - End Of Tape (EOT) marker block.
 


  C2F Format

  C2F - Commodore 264 Freeze format. The table below shows its structure.

OFFSET  AREA NAME       LENGTH  COMMENTS

------- FORMAT SPECIFICATION -----------
0       VERSION         2       1 FOR VERSION 1.1x OF THE EMULATOR

------- ADDITIONAL INFORMATION ---------
2       CPU TIME        1       TICKS TO CPU

------- CPU REGISTERS ------------------
3       PC              2
5       SP              2       HIGH BYTE = 1
7       XR              2       HIGH BYTE = 0
9       YR              2       HIGH BYTE = 0
0BH     SR              1
0CH     AC              1

------- CPU PORTS ----------------------
0DH     $0              1
0EH     $1              1

------- MEMORY CONFIGURATION -----------
0FH     ROMMAP          1
10H                     1       RESERVED

------- TED ----------------------------
11H     TIMER #1 RELOAD
        VALUE           2

------- ADDITIONAL INFORMATION ---------
13H     LED             1       KBD LED INDICATOR DATA

------- TED ----------------------------
14H     TED REGISTERS   20H(32)

------- RAM ----------------------------
34H     $2-$FFFF        0FFFEH(65534)



  Compilation

  You need FASM V1.46 or newer (http://fasm.sourceforge.net/) for sources
compilation.
  Command `fasm plus4.asm plus4.exe' creates the emulator executable file.
Use FASM in the pure DOS (without memory managers like EMM386) or in any
Linux.



  (C) Copyright 

  Almost all data and program files of this package are written by Lidovski V.
in X/1996 - IV/1997, VI-VIII/1998, XII/1998, IV/2000, XI/2002, III-VII/2003.
   All source code is Copyright (C) 2003 Lidovski Vladimir. This program is
distributed under the GNU General Public License, Version 2, or, at your
discretion, any later version. The GNU General Public License is available
via the Web at <http://www.gnu.org/copyleft/gpl.html>. The GPL is designed
to allow you to alter and redistribute the package, as long as you do not
remove that freedom from others.



  Changes List

  The next bugs fixed and features added since version 1.00 of this emulator:
  * debugger can't hang computer after g or p command in long execution
    sequence
  * q debugger command returns to the non debugger mode of execution and
    g debugger command turns emulator in the debugger mode
  * button End correctly works in menus
  * added analog joysticks support
  * screen size set to 320x207
  * TED algorithm slightly modified

  bugs fixed in v1.12 (XI-2002)
  * made correct kernal $FCxx page fix
  * made correct loading of PRG-files with tape origin, like PACMANIA

  features of v1.14
  * added full range of joysticks emulation options
  * vertical synchronization set to 50.1Hz (early it was 54.6Hz)
  * added possibility to use the underscore symbol in the filenames in the
    menus

  features of v1.15
  * it's the last version of emulator which can run at 100% speed at P100

  features of v1.16 (III-2003)
  * improved interrupts handling - it does possible to run Icicle Works
    without problems
  * added poor digital sound effects support (that reached by reducing delays
    after writing to AdLib ports and may create problems with very old cards)
  * it's the last version of the emulator which can run at 100% speed at P133

  features of v1.17 (IV-2003)
  * added PC speaker sound support - this does possible to hear digital sound
    effects (use F5 to change sound hardware) and does impossible to run the
    emulator from Microsoft Windows
  * added O (watchpOint) command to the debugger
  * added speed regulation to the menus
  * completly rewritten synchronization codes (now it based on the timer
    37.3KHz interrupt)
  * added support for mouse buttons to the emulator
  * fixed some minor bugs

  features of v1.18 (V-2003)
  * first version for free assembler (FASM) under GNU GPL
  * fixed some bugs

  features of v1.19 (VII-2003)
  * better hardware interrupts handling algorithm (old one could cause crash
    of menus subsystem and hanging of computer with DR-DOS, Free-DOS, and
    PTS-DOS, but worked good on Microsoft MS-DOS!)
  * better synchronization code
  * renamed KERNEL.ROM to KERNAL.ROM
  * fixed several bugs in the debugger
  * added some little improvements to the TED subroutine (that cause better
    look of the games SQUIRM, JAILBREAK, ...)
  * menus: added DELETE command and one navigation bug fixed
  * it's first named version of the emulator (`Navsegda' in Russian)
  * slightly improved PC speaker sound code
  * better drive letters handling
  * CD-ROMs support added
  * improved LED (lock keys indicators) handling

